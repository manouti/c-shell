/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : Guolice.g
 *     -                            On : 2010-12-22 16:48:11
 *     -                for the parser : GuoliceParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "GuoliceParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pGuoliceParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pGuoliceParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pGuoliceParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pGuoliceParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   GuoliceParserTokenNames[58+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "ID",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "STRING_LITERAL",
        (pANTLR3_UINT8) "LETTER",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'procedure'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'end'",
        (pANTLR3_UINT8) "'function'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "':='",
        (pANTLR3_UINT8) "'constant'",
        (pANTLR3_UINT8) "'var'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'then'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'while'",
        (pANTLR3_UINT8) "'loop'",
        (pANTLR3_UINT8) "'exit'",
        (pANTLR3_UINT8) "'when'",
        (pANTLR3_UINT8) "'now'",
        (pANTLR3_UINT8) "'return'",
        (pANTLR3_UINT8) "'NOT'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "'MOD'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'!='",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'AND'",
        (pANTLR3_UINT8) "'OR'",
        (pANTLR3_UINT8) "'int'",
        (pANTLR3_UINT8) "'bool'",
        (pANTLR3_UINT8) "'string'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'Box'",
        (pANTLR3_UINT8) "'Circle'",
        (pANTLR3_UINT8) "'Triangle'",
        (pANTLR3_UINT8) "'Label'",
        (pANTLR3_UINT8) "'OnClick'",
        (pANTLR3_UINT8) "'KeyPress'",
        (pANTLR3_UINT8) "'LeftOf'",
        (pANTLR3_UINT8) "'RightOf'",
        (pANTLR3_UINT8) "'Above'",
        (pANTLR3_UINT8) "'Below'",
        (pANTLR3_UINT8) "'Contains'",
        (pANTLR3_UINT8) "'Intersect'",
        (pANTLR3_UINT8) "'SmallerThan'",
        (pANTLR3_UINT8) "'BiggerThan'",
        (pANTLR3_UINT8) "'EqualTo'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	program    (pGuoliceParser ctx);
static void	procedureDec    (pGuoliceParser ctx);
static void	functionDec    (pGuoliceParser ctx);
static void	parameters    (pGuoliceParser ctx);
static Node*	statement    (pGuoliceParser ctx);
static Node*	assignmentStatement    (pGuoliceParser ctx);
static Node*	constantDecStatement    (pGuoliceParser ctx);
static Node*	variableDecStatement    (pGuoliceParser ctx);
static Node*	ifStatement    (pGuoliceParser ctx);
static Node *	whileStatement    (pGuoliceParser ctx);
static Node *	procedureCallStatement    (pGuoliceParser ctx);
static GuoliceParser_actualParameters_return	actualParameters    (pGuoliceParser ctx);
static void	exitStatement    (pGuoliceParser ctx);
static void	returnStatement    (pGuoliceParser ctx);
static Node *	term    (pGuoliceParser ctx);
static Node *	negation    (pGuoliceParser ctx);
static Node *	unary    (pGuoliceParser ctx);
static Node*	multdiv    (pGuoliceParser ctx);
static Node*	addsub    (pGuoliceParser ctx);
static Node*	compare    (pGuoliceParser ctx);
static Node*	expression    (pGuoliceParser ctx);
static GuoliceParser_type_return	type    (pGuoliceParser ctx);
static Node*	guiDecStatement    (pGuoliceParser ctx);
static Node*	guiTerm    (pGuoliceParser ctx);
static Node*	guiPositionExpression    (pGuoliceParser ctx);
static Node*	guiComparisonExpression    (pGuoliceParser ctx);
static Node*	guiStatement    (pGuoliceParser ctx);
static Node*	evntHandleStatement    (pGuoliceParser ctx);
static GuoliceParser_guiType_return	guiType    (pGuoliceParser ctx);
static GuoliceParser_eventType_return	eventType    (pGuoliceParser ctx);
static GuoliceParser_positionKeyword_return	positionKeyword    (pGuoliceParser ctx);
static GuoliceParser_guiComparsionTerm_return	guiComparsionTerm    (pGuoliceParser ctx);
static void	GuoliceParserFree(pGuoliceParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Guolice.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new GuoliceParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pGuoliceParser
GuoliceParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return GuoliceParserNewSSD(instream, NULL);
}

/** \brief Create a new GuoliceParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pGuoliceParser
GuoliceParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pGuoliceParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pGuoliceParser) ANTLR3_CALLOC(1, sizeof(GuoliceParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in GuoliceParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our GuoliceParser interface
     */
    ctx->program	= program;
    ctx->procedureDec	= procedureDec;
    ctx->functionDec	= functionDec;
    ctx->parameters	= parameters;
    ctx->statement	= statement;
    ctx->assignmentStatement	= assignmentStatement;
    ctx->constantDecStatement	= constantDecStatement;
    ctx->variableDecStatement	= variableDecStatement;
    ctx->ifStatement	= ifStatement;
    ctx->whileStatement	= whileStatement;
    ctx->procedureCallStatement	= procedureCallStatement;
    ctx->actualParameters	= actualParameters;
    ctx->exitStatement	= exitStatement;
    ctx->returnStatement	= returnStatement;
    ctx->term	= term;
    ctx->negation	= negation;
    ctx->unary	= unary;
    ctx->multdiv	= multdiv;
    ctx->addsub	= addsub;
    ctx->compare	= compare;
    ctx->expression	= expression;
    ctx->type	= type;
    ctx->guiDecStatement	= guiDecStatement;
    ctx->guiTerm	= guiTerm;
    ctx->guiPositionExpression	= guiPositionExpression;
    ctx->guiComparisonExpression	= guiComparisonExpression;
    ctx->guiStatement	= guiStatement;
    ctx->evntHandleStatement	= evntHandleStatement;
    ctx->guiType	= guiType;
    ctx->eventType	= eventType;
    ctx->positionKeyword	= positionKeyword;
    ctx->guiComparsionTerm	= guiComparsionTerm;
    ctx->free			= GuoliceParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = GuoliceParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 GuoliceParserFree(pGuoliceParser ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return GuoliceParserTokenNames; 
}


    	Node* root;
    	vector<Node*> variableDeclNodes;
    	vector<Node*> guiDeclNodes;
    	vector<FunctionNode*> functionList;
    	map<string, string> functionParameters;
    	vector<Node*> statements;
    	
    	map<Node*, string> variableIDs;
    	
    /** \function
    *	\param Node* pointer from the Type Node
    *	
    *	\brief Print the nodes in the tree
    *
    */
    	void printTree(Node* node) {
    		cout << "\nNode: " << node->toString() << endl;
    		for(int i = 0; i < node->getChildren().size(); i++) 
    		{
    			printTree(node->getChildren().at(i));
    		}
    	}

    /** \function
    *	\brief Print the list of the Function or the procedure members
    *
    */ 
    	void printFunctionList() {
    		cout << "[ ";
    		for (int i=0; i < functionList.size(); i++) 
    		{
    			cout << functionList[i]->toString() << "The function " << functionList[i]->getValue() << " members : ";
    			for (int j=0; j < functionList[i]->getChildren().size(); j++)
    			{ 
    				printTree(functionList[i]->getChildren().at(j));
    			}
    			cout << endl;
    		}
    		cout << "]\n";
    	}
    	
    	/**
    	  Prints the node information in the dot format.
    	*/
    	/*string visitNode(Node* node) {
    		string nodeDot ("node");
    		
    		stringstream oss;
    		oss << dotNodeCount++;
    		nodeDot += oss.str();
    		
    		nodeNames[node] = nodeDot; // Store the label of the node in the dot file, e.g. node13 in the map "nodeNames"
    		
    		nodeDot += "[label=\"";
    		nodeDot += node->getValue();
    		nodeDot += "\",";
    		switch(node->getType()) {
    			case Node::VAR:
    				{
    				string variableColor;
    				
    				if (varColors.find(node->getValue()) != varColors.end()) {
    					variableColor = varColors[node->getValue()];
    				}
    				else {
    					double red = static_cast<double> (rand()) / static_cast<double> (RAND_MAX);
    					double green = static_cast<double> (rand()) / static_cast<double> (RAND_MAX);
    					double blue = static_cast<double> (rand()) / static_cast<double> (RAND_MAX);
    					
    					oss.flush();
    					oss << red << " " << green << " " << blue;
    					variableColor = oss.str();
    					
    					varColors[node->getValue()] = variableColor;
    				}
    				
    				nodeDot += "rank=sink,style=filled,color=\"" + variableColor +  "\"];\n";
    				}
    				break;
    			case Node::CONST:
    				nodeDot += "shape=box];\n";
    				break;
    			case Node::OP:
    				 nodeDot += "shape=diamond];\n";
    		}
    		
    		return nodeDot;
    	}*/
    	
    	/**
    	  Prints the edge information in the dot format.
    	*/
    	/*string visitEdge(Node* node1, Node* node2) {
    		string edgeDot ("\n");
    		edgeDot += nodeNames[node1] + " -> " + nodeNames[node2] + ";";
    		return edgeDot;
    	}
    	
      	void getNodesDot(Node* node, ofstream& dotFile) {
    		dotFile << visitNode(node);
      		
      		for(int i = 0; i < node->getChildren().size(); i++) 
    		{
    			getNodesDot(node->getChildren().at(i), dotFile);
    		}
    	}

    	void getEdgesDot(Node* parent, ofstream& dotFile) {
    		for(int i = 0; i < parent->getChildren().size(); i++) {
    			dotFile << visitEdge(parent, parent->getChildren().at(i));
    			getEdgesDot(parent->getChildren().at(i), dotFile);
    		}
    	}
    	
    	void getDot(char* fileName) {
    		ofstream dotFile;
      		dotFile.open(fileName);
      		
      		dotFile << "digraph GuoliceParseGraph  {\n";
      		dotFile << "graph[ordering=out];\n";

    		dotFile << "//------------------- Node declarations -------------------\n";  		
      		getNodesDot(root, dotFile);

    		dotFile << "//------------------- Edge declarations -------------------\n";  		
    		getEdgesDot(root, dotFile);
    				
    		dotFile << "}";
    		
      		dotFile.close();
      	}*/

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedureDec_in_program69  */
static	ANTLR3_BITWORD FOLLOW_procedureDec_in_program69_bits[]	= { ANTLR3_UINT64_LIT(0x0007800002752812) };
static  ANTLR3_BITSET_LIST FOLLOW_procedureDec_in_program69	= { FOLLOW_procedureDec_in_program69_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionDec_in_program73  */
static	ANTLR3_BITWORD FOLLOW_functionDec_in_program73_bits[]	= { ANTLR3_UINT64_LIT(0x0007800002752812) };
static  ANTLR3_BITSET_LIST FOLLOW_functionDec_in_program73	= { FOLLOW_functionDec_in_program73_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_program77  */
static	ANTLR3_BITWORD FOLLOW_statement_in_program77_bits[]	= { ANTLR3_UINT64_LIT(0x0007800002752812) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_program77	= { FOLLOW_statement_in_program77_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_11_in_procedureDec99  */
static	ANTLR3_BITWORD FOLLOW_11_in_procedureDec99_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_11_in_procedureDec99	= { FOLLOW_11_in_procedureDec99_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_12_in_procedureDec101  */
static	ANTLR3_BITWORD FOLLOW_12_in_procedureDec101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_12_in_procedureDec101	= { FOLLOW_12_in_procedureDec101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_procedureDec103  */
static	ANTLR3_BITWORD FOLLOW_ID_in_procedureDec103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_procedureDec103	= { FOLLOW_ID_in_procedureDec103_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_procedureDec109  */
static	ANTLR3_BITWORD FOLLOW_13_in_procedureDec109_bits[]	= { ANTLR3_UINT64_LIT(0x0000380000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_procedureDec109	= { FOLLOW_13_in_procedureDec109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameters_in_procedureDec112  */
static	ANTLR3_BITWORD FOLLOW_parameters_in_procedureDec112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_parameters_in_procedureDec112	= { FOLLOW_parameters_in_procedureDec112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_procedureDec119  */
static	ANTLR3_BITWORD FOLLOW_14_in_procedureDec119_bits[]	= { ANTLR3_UINT64_LIT(0x000780000A75A810) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_procedureDec119	= { FOLLOW_14_in_procedureDec119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_procedureDec125  */
static	ANTLR3_BITWORD FOLLOW_statement_in_procedureDec125_bits[]	= { ANTLR3_UINT64_LIT(0x000780000A75A810) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_procedureDec125	= { FOLLOW_statement_in_procedureDec125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exitStatement_in_procedureDec137  */
static	ANTLR3_BITWORD FOLLOW_exitStatement_in_procedureDec137_bits[]	= { ANTLR3_UINT64_LIT(0x000780000A75A810) };
static  ANTLR3_BITSET_LIST FOLLOW_exitStatement_in_procedureDec137	= { FOLLOW_exitStatement_in_procedureDec137_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_procedureDec148  */
static	ANTLR3_BITWORD FOLLOW_15_in_procedureDec148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_procedureDec148	= { FOLLOW_15_in_procedureDec148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_11_in_procedureDec150  */
static	ANTLR3_BITWORD FOLLOW_11_in_procedureDec150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_11_in_procedureDec150	= { FOLLOW_11_in_procedureDec150_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_16_in_functionDec168  */
static	ANTLR3_BITWORD FOLLOW_16_in_functionDec168_bits[]	= { ANTLR3_UINT64_LIT(0x0000380000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_16_in_functionDec168	= { FOLLOW_16_in_functionDec168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_functionDec170  */
static	ANTLR3_BITWORD FOLLOW_type_in_functionDec170_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_functionDec170	= { FOLLOW_type_in_functionDec170_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_12_in_functionDec172  */
static	ANTLR3_BITWORD FOLLOW_12_in_functionDec172_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_12_in_functionDec172	= { FOLLOW_12_in_functionDec172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_functionDec174  */
static	ANTLR3_BITWORD FOLLOW_ID_in_functionDec174_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_functionDec174	= { FOLLOW_ID_in_functionDec174_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_functionDec180  */
static	ANTLR3_BITWORD FOLLOW_13_in_functionDec180_bits[]	= { ANTLR3_UINT64_LIT(0x0000380000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_functionDec180	= { FOLLOW_13_in_functionDec180_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameters_in_functionDec183  */
static	ANTLR3_BITWORD FOLLOW_parameters_in_functionDec183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_parameters_in_functionDec183	= { FOLLOW_parameters_in_functionDec183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_functionDec190  */
static	ANTLR3_BITWORD FOLLOW_14_in_functionDec190_bits[]	= { ANTLR3_UINT64_LIT(0x0007800042752810) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_functionDec190	= { FOLLOW_14_in_functionDec190_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_functionDec198  */
static	ANTLR3_BITWORD FOLLOW_statement_in_functionDec198_bits[]	= { ANTLR3_UINT64_LIT(0x0007800042752810) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_functionDec198	= { FOLLOW_statement_in_functionDec198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_returnStatement_in_functionDec208  */
static	ANTLR3_BITWORD FOLLOW_returnStatement_in_functionDec208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_returnStatement_in_functionDec208	= { FOLLOW_returnStatement_in_functionDec208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_functionDec213  */
static	ANTLR3_BITWORD FOLLOW_15_in_functionDec213_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_functionDec213	= { FOLLOW_15_in_functionDec213_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_16_in_functionDec215  */
static	ANTLR3_BITWORD FOLLOW_16_in_functionDec215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_16_in_functionDec215	= { FOLLOW_16_in_functionDec215_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_parameters230  */
static	ANTLR3_BITWORD FOLLOW_type_in_parameters230_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_parameters230	= { FOLLOW_type_in_parameters230_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_12_in_parameters233  */
static	ANTLR3_BITWORD FOLLOW_12_in_parameters233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_12_in_parameters233	= { FOLLOW_12_in_parameters233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_parameters237  */
static	ANTLR3_BITWORD FOLLOW_ID_in_parameters237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_parameters237	= { FOLLOW_ID_in_parameters237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_17_in_parameters249  */
static	ANTLR3_BITWORD FOLLOW_17_in_parameters249_bits[]	= { ANTLR3_UINT64_LIT(0x0000380000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_17_in_parameters249	= { FOLLOW_17_in_parameters249_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_parameters253  */
static	ANTLR3_BITWORD FOLLOW_type_in_parameters253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_parameters253	= { FOLLOW_type_in_parameters253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_12_in_parameters256  */
static	ANTLR3_BITWORD FOLLOW_12_in_parameters256_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_12_in_parameters256	= { FOLLOW_12_in_parameters256_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_parameters260  */
static	ANTLR3_BITWORD FOLLOW_ID_in_parameters260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_parameters260	= { FOLLOW_ID_in_parameters260_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_statement291  */
static	ANTLR3_BITWORD FOLLOW_18_in_statement291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_statement291	= { FOLLOW_18_in_statement291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignmentStatement_in_statement296  */
static	ANTLR3_BITWORD FOLLOW_assignmentStatement_in_statement296_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignmentStatement_in_statement296	= { FOLLOW_assignmentStatement_in_statement296_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constantDecStatement_in_statement306  */
static	ANTLR3_BITWORD FOLLOW_constantDecStatement_in_statement306_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constantDecStatement_in_statement306	= { FOLLOW_constantDecStatement_in_statement306_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDecStatement_in_statement316  */
static	ANTLR3_BITWORD FOLLOW_variableDecStatement_in_statement316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDecStatement_in_statement316	= { FOLLOW_variableDecStatement_in_statement316_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_statement326  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_statement326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_statement326	= { FOLLOW_ifStatement_in_statement326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_whileStatement_in_statement337  */
static	ANTLR3_BITWORD FOLLOW_whileStatement_in_statement337_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_whileStatement_in_statement337	= { FOLLOW_whileStatement_in_statement337_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_procedureCallStatement_in_statement347  */
static	ANTLR3_BITWORD FOLLOW_procedureCallStatement_in_statement347_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_procedureCallStatement_in_statement347	= { FOLLOW_procedureCallStatement_in_statement347_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiStatement_in_statement357  */
static	ANTLR3_BITWORD FOLLOW_guiStatement_in_statement357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_guiStatement_in_statement357	= { FOLLOW_guiStatement_in_statement357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_evntHandleStatement_in_statement367  */
static	ANTLR3_BITWORD FOLLOW_evntHandleStatement_in_statement367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_evntHandleStatement_in_statement367	= { FOLLOW_evntHandleStatement_in_statement367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_assignmentStatement396  */
static	ANTLR3_BITWORD FOLLOW_ID_in_assignmentStatement396_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_assignmentStatement396	= { FOLLOW_ID_in_assignmentStatement396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_assignmentStatement398  */
static	ANTLR3_BITWORD FOLLOW_19_in_assignmentStatement398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_assignmentStatement398	= { FOLLOW_19_in_assignmentStatement398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_assignmentStatement400  */
static	ANTLR3_BITWORD FOLLOW_expression_in_assignmentStatement400_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_assignmentStatement400	= { FOLLOW_expression_in_assignmentStatement400_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_assignmentStatement402  */
static	ANTLR3_BITWORD FOLLOW_18_in_assignmentStatement402_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_assignmentStatement402	= { FOLLOW_18_in_assignmentStatement402_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_20_in_constantDecStatement426  */
static	ANTLR3_BITWORD FOLLOW_20_in_constantDecStatement426_bits[]	= { ANTLR3_UINT64_LIT(0x0000380000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_20_in_constantDecStatement426	= { FOLLOW_20_in_constantDecStatement426_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_constantDecStatement428  */
static	ANTLR3_BITWORD FOLLOW_type_in_constantDecStatement428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_constantDecStatement428	= { FOLLOW_type_in_constantDecStatement428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_12_in_constantDecStatement430  */
static	ANTLR3_BITWORD FOLLOW_12_in_constantDecStatement430_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_12_in_constantDecStatement430	= { FOLLOW_12_in_constantDecStatement430_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_constantDecStatement432  */
static	ANTLR3_BITWORD FOLLOW_ID_in_constantDecStatement432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_constantDecStatement432	= { FOLLOW_ID_in_constantDecStatement432_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_constantDecStatement435  */
static	ANTLR3_BITWORD FOLLOW_19_in_constantDecStatement435_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_constantDecStatement435	= { FOLLOW_19_in_constantDecStatement435_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_constantDecStatement437  */
static	ANTLR3_BITWORD FOLLOW_expression_in_constantDecStatement437_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_constantDecStatement437	= { FOLLOW_expression_in_constantDecStatement437_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_constantDecStatement439  */
static	ANTLR3_BITWORD FOLLOW_18_in_constantDecStatement439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_constantDecStatement439	= { FOLLOW_18_in_constantDecStatement439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_21_in_variableDecStatement463  */
static	ANTLR3_BITWORD FOLLOW_21_in_variableDecStatement463_bits[]	= { ANTLR3_UINT64_LIT(0x0000380000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_21_in_variableDecStatement463	= { FOLLOW_21_in_variableDecStatement463_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_variableDecStatement465  */
static	ANTLR3_BITWORD FOLLOW_type_in_variableDecStatement465_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_type_in_variableDecStatement465	= { FOLLOW_type_in_variableDecStatement465_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_12_in_variableDecStatement467  */
static	ANTLR3_BITWORD FOLLOW_12_in_variableDecStatement467_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_12_in_variableDecStatement467	= { FOLLOW_12_in_variableDecStatement467_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_variableDecStatement471  */
static	ANTLR3_BITWORD FOLLOW_ID_in_variableDecStatement471_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_variableDecStatement471	= { FOLLOW_ID_in_variableDecStatement471_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_19_in_variableDecStatement480  */
static	ANTLR3_BITWORD FOLLOW_19_in_variableDecStatement480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_19_in_variableDecStatement480	= { FOLLOW_19_in_variableDecStatement480_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_variableDecStatement484  */
static	ANTLR3_BITWORD FOLLOW_expression_in_variableDecStatement484_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_variableDecStatement484	= { FOLLOW_expression_in_variableDecStatement484_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_variableDecStatement497  */
static	ANTLR3_BITWORD FOLLOW_18_in_variableDecStatement497_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_variableDecStatement497	= { FOLLOW_18_in_variableDecStatement497_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_ifStatement517  */
static	ANTLR3_BITWORD FOLLOW_22_in_ifStatement517_bits[]	= { ANTLR3_UINT64_LIT(0x0007800380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_ifStatement517	= { FOLLOW_22_in_ifStatement517_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_ifStatement522  */
static	ANTLR3_BITWORD FOLLOW_expression_in_ifStatement522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_ifStatement522	= { FOLLOW_expression_in_ifStatement522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiComparisonExpression_in_ifStatement528  */
static	ANTLR3_BITWORD FOLLOW_guiComparisonExpression_in_ifStatement528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_guiComparisonExpression_in_ifStatement528	= { FOLLOW_guiComparisonExpression_in_ifStatement528_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_ifStatement532  */
static	ANTLR3_BITWORD FOLLOW_13_in_ifStatement532_bits[]	= { ANTLR3_UINT64_LIT(0x0007800000002010) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_ifStatement532	= { FOLLOW_13_in_ifStatement532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiComparisonExpression_in_ifStatement536  */
static	ANTLR3_BITWORD FOLLOW_guiComparisonExpression_in_ifStatement536_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_guiComparisonExpression_in_ifStatement536	= { FOLLOW_guiComparisonExpression_in_ifStatement536_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_ifStatement538  */
static	ANTLR3_BITWORD FOLLOW_14_in_ifStatement538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_ifStatement538	= { FOLLOW_14_in_ifStatement538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiPositionExpression_in_ifStatement544  */
static	ANTLR3_BITWORD FOLLOW_guiPositionExpression_in_ifStatement544_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_guiPositionExpression_in_ifStatement544	= { FOLLOW_guiPositionExpression_in_ifStatement544_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_ifStatement548  */
static	ANTLR3_BITWORD FOLLOW_23_in_ifStatement548_bits[]	= { ANTLR3_UINT64_LIT(0x000780000375A810) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_ifStatement548	= { FOLLOW_23_in_ifStatement548_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement560  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement560_bits[]	= { ANTLR3_UINT64_LIT(0x000780000375A810) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement560	= { FOLLOW_statement_in_ifStatement560_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_24_in_ifStatement571  */
static	ANTLR3_BITWORD FOLLOW_24_in_ifStatement571_bits[]	= { ANTLR3_UINT64_LIT(0x000780000275A810) };
static  ANTLR3_BITSET_LIST FOLLOW_24_in_ifStatement571	= { FOLLOW_24_in_ifStatement571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement584  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement584_bits[]	= { ANTLR3_UINT64_LIT(0x000780000275A810) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement584	= { FOLLOW_statement_in_ifStatement584_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_ifStatement595  */
static	ANTLR3_BITWORD FOLLOW_15_in_ifStatement595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_ifStatement595	= { FOLLOW_15_in_ifStatement595_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_ifStatement597  */
static	ANTLR3_BITWORD FOLLOW_22_in_ifStatement597_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_ifStatement597	= { FOLLOW_22_in_ifStatement597_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_whileStatement616  */
static	ANTLR3_BITWORD FOLLOW_25_in_whileStatement616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_whileStatement616	= { FOLLOW_25_in_whileStatement616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_whileStatement623  */
static	ANTLR3_BITWORD FOLLOW_expression_in_whileStatement623_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_whileStatement623	= { FOLLOW_expression_in_whileStatement623_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_26_in_whileStatement629  */
static	ANTLR3_BITWORD FOLLOW_26_in_whileStatement629_bits[]	= { ANTLR3_UINT64_LIT(0x000780000A75A810) };
static  ANTLR3_BITSET_LIST FOLLOW_26_in_whileStatement629	= { FOLLOW_26_in_whileStatement629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_whileStatement636  */
static	ANTLR3_BITWORD FOLLOW_statement_in_whileStatement636_bits[]	= { ANTLR3_UINT64_LIT(0x000780000A75A810) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_whileStatement636	= { FOLLOW_statement_in_whileStatement636_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exitStatement_in_whileStatement642  */
static	ANTLR3_BITWORD FOLLOW_exitStatement_in_whileStatement642_bits[]	= { ANTLR3_UINT64_LIT(0x000780000A75A810) };
static  ANTLR3_BITSET_LIST FOLLOW_exitStatement_in_whileStatement642	= { FOLLOW_exitStatement_in_whileStatement642_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_15_in_whileStatement649  */
static	ANTLR3_BITWORD FOLLOW_15_in_whileStatement649_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_15_in_whileStatement649	= { FOLLOW_15_in_whileStatement649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_26_in_whileStatement651  */
static	ANTLR3_BITWORD FOLLOW_26_in_whileStatement651_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_26_in_whileStatement651	= { FOLLOW_26_in_whileStatement651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_procedureCallStatement670  */
static	ANTLR3_BITWORD FOLLOW_ID_in_procedureCallStatement670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_procedureCallStatement670	= { FOLLOW_ID_in_procedureCallStatement670_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_procedureCallStatement674  */
static	ANTLR3_BITWORD FOLLOW_13_in_procedureCallStatement674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_procedureCallStatement674	= { FOLLOW_13_in_procedureCallStatement674_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_actualParameters_in_procedureCallStatement676  */
static	ANTLR3_BITWORD FOLLOW_actualParameters_in_procedureCallStatement676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_actualParameters_in_procedureCallStatement676	= { FOLLOW_actualParameters_in_procedureCallStatement676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_procedureCallStatement678  */
static	ANTLR3_BITWORD FOLLOW_14_in_procedureCallStatement678_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_procedureCallStatement678	= { FOLLOW_14_in_procedureCallStatement678_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_procedureCallStatement689  */
static	ANTLR3_BITWORD FOLLOW_13_in_procedureCallStatement689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_procedureCallStatement689	= { FOLLOW_13_in_procedureCallStatement689_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_procedureCallStatement691  */
static	ANTLR3_BITWORD FOLLOW_14_in_procedureCallStatement691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_procedureCallStatement691	= { FOLLOW_14_in_procedureCallStatement691_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_procedureCallStatement701  */
static	ANTLR3_BITWORD FOLLOW_18_in_procedureCallStatement701_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_procedureCallStatement701	= { FOLLOW_18_in_procedureCallStatement701_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_actualParameters719  */
static	ANTLR3_BITWORD FOLLOW_expression_in_actualParameters719_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_actualParameters719	= { FOLLOW_expression_in_actualParameters719_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_17_in_actualParameters728  */
static	ANTLR3_BITWORD FOLLOW_17_in_actualParameters728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_17_in_actualParameters728	= { FOLLOW_17_in_actualParameters728_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_actualParameters732  */
static	ANTLR3_BITWORD FOLLOW_expression_in_actualParameters732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_actualParameters732	= { FOLLOW_expression_in_actualParameters732_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_exitStatement754  */
static	ANTLR3_BITWORD FOLLOW_27_in_exitStatement754_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_exitStatement754	= { FOLLOW_27_in_exitStatement754_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_exitStatement755  */
static	ANTLR3_BITWORD FOLLOW_28_in_exitStatement755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_exitStatement755	= { FOLLOW_28_in_exitStatement755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_exitStatement757  */
static	ANTLR3_BITWORD FOLLOW_expression_in_exitStatement757_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_exitStatement757	= { FOLLOW_expression_in_exitStatement757_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_exitStatement759  */
static	ANTLR3_BITWORD FOLLOW_18_in_exitStatement759_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_exitStatement759	= { FOLLOW_18_in_exitStatement759_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_exitStatement764  */
static	ANTLR3_BITWORD FOLLOW_27_in_exitStatement764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_exitStatement764	= { FOLLOW_27_in_exitStatement764_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_exitStatement765  */
static	ANTLR3_BITWORD FOLLOW_29_in_exitStatement765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_exitStatement765	= { FOLLOW_29_in_exitStatement765_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_exitStatement766  */
static	ANTLR3_BITWORD FOLLOW_18_in_exitStatement766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_exitStatement766	= { FOLLOW_18_in_exitStatement766_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_returnStatement781  */
static	ANTLR3_BITWORD FOLLOW_30_in_returnStatement781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_returnStatement781	= { FOLLOW_30_in_returnStatement781_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_returnStatement783  */
static	ANTLR3_BITWORD FOLLOW_expression_in_returnStatement783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_returnStatement783	= { FOLLOW_expression_in_returnStatement783_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_returnStatement785  */
static	ANTLR3_BITWORD FOLLOW_18_in_returnStatement785_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_returnStatement785	= { FOLLOW_18_in_returnStatement785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_term805  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_term805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_term805	= { FOLLOW_INTEGER_in_term805_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_term815  */
static	ANTLR3_BITWORD FOLLOW_13_in_term815_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_term815	= { FOLLOW_13_in_term815_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_term817  */
static	ANTLR3_BITWORD FOLLOW_expression_in_term817_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_term817	= { FOLLOW_expression_in_term817_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_term819  */
static	ANTLR3_BITWORD FOLLOW_14_in_term819_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_term819	= { FOLLOW_14_in_term819_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_term829  */
static	ANTLR3_BITWORD FOLLOW_ID_in_term829_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_term829	= { FOLLOW_ID_in_term829_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_term839  */
static	ANTLR3_BITWORD FOLLOW_ID_in_term839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_term839	= { FOLLOW_ID_in_term839_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_term841  */
static	ANTLR3_BITWORD FOLLOW_13_in_term841_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_term841	= { FOLLOW_13_in_term841_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_actualParameters_in_term843  */
static	ANTLR3_BITWORD FOLLOW_actualParameters_in_term843_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_actualParameters_in_term843	= { FOLLOW_actualParameters_in_term843_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_term845  */
static	ANTLR3_BITWORD FOLLOW_14_in_term845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_term845	= { FOLLOW_14_in_term845_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_term855  */
static	ANTLR3_BITWORD FOLLOW_ID_in_term855_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_term855	= { FOLLOW_ID_in_term855_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_term857  */
static	ANTLR3_BITWORD FOLLOW_13_in_term857_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_term857	= { FOLLOW_13_in_term857_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_term859  */
static	ANTLR3_BITWORD FOLLOW_14_in_term859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_term859	= { FOLLOW_14_in_term859_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_term869  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_term869_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_term869	= { FOLLOW_STRING_LITERAL_in_term869_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_negation897  */
static	ANTLR3_BITWORD FOLLOW_31_in_negation897_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_negation897	= { FOLLOW_31_in_negation897_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_negation904  */
static	ANTLR3_BITWORD FOLLOW_term_in_negation904_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_term_in_negation904	= { FOLLOW_term_in_negation904_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_unary930  */
static	ANTLR3_BITWORD FOLLOW_32_in_unary930_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_unary930	= { FOLLOW_32_in_unary930_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_unary934  */
static	ANTLR3_BITWORD FOLLOW_33_in_unary934_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_unary934	= { FOLLOW_33_in_unary934_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_negation_in_unary940  */
static	ANTLR3_BITWORD FOLLOW_negation_in_unary940_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_negation_in_unary940	= { FOLLOW_negation_in_unary940_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unary_in_multdiv966  */
static	ANTLR3_BITWORD FOLLOW_unary_in_multdiv966_bits[]	= { ANTLR3_UINT64_LIT(0x0000001C00000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unary_in_multdiv966	= { FOLLOW_unary_in_multdiv966_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_multdiv973  */
static	ANTLR3_BITWORD FOLLOW_34_in_multdiv973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_multdiv973	= { FOLLOW_34_in_multdiv973_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unary_in_multdiv977  */
static	ANTLR3_BITWORD FOLLOW_unary_in_multdiv977_bits[]	= { ANTLR3_UINT64_LIT(0x0000001C00000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unary_in_multdiv977	= { FOLLOW_unary_in_multdiv977_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_multdiv989  */
static	ANTLR3_BITWORD FOLLOW_35_in_multdiv989_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_multdiv989	= { FOLLOW_35_in_multdiv989_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unary_in_multdiv993  */
static	ANTLR3_BITWORD FOLLOW_unary_in_multdiv993_bits[]	= { ANTLR3_UINT64_LIT(0x0000001C00000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unary_in_multdiv993	= { FOLLOW_unary_in_multdiv993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_multdiv1006  */
static	ANTLR3_BITWORD FOLLOW_36_in_multdiv1006_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_multdiv1006	= { FOLLOW_36_in_multdiv1006_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unary_in_multdiv1010  */
static	ANTLR3_BITWORD FOLLOW_unary_in_multdiv1010_bits[]	= { ANTLR3_UINT64_LIT(0x0000001C00000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unary_in_multdiv1010	= { FOLLOW_unary_in_multdiv1010_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multdiv_in_addsub1049  */
static	ANTLR3_BITWORD FOLLOW_multdiv_in_addsub1049_bits[]	= { ANTLR3_UINT64_LIT(0x0000000300000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multdiv_in_addsub1049	= { FOLLOW_multdiv_in_addsub1049_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_addsub1056  */
static	ANTLR3_BITWORD FOLLOW_32_in_addsub1056_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_addsub1056	= { FOLLOW_32_in_addsub1056_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multdiv_in_addsub1060  */
static	ANTLR3_BITWORD FOLLOW_multdiv_in_addsub1060_bits[]	= { ANTLR3_UINT64_LIT(0x0000000300000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multdiv_in_addsub1060	= { FOLLOW_multdiv_in_addsub1060_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_addsub1073  */
static	ANTLR3_BITWORD FOLLOW_33_in_addsub1073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_addsub1073	= { FOLLOW_33_in_addsub1073_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multdiv_in_addsub1077  */
static	ANTLR3_BITWORD FOLLOW_multdiv_in_addsub1077_bits[]	= { ANTLR3_UINT64_LIT(0x0000000300000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multdiv_in_addsub1077	= { FOLLOW_multdiv_in_addsub1077_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addsub_in_compare1116  */
static	ANTLR3_BITWORD FOLLOW_addsub_in_compare1116_bits[]	= { ANTLR3_UINT64_LIT(0x000001E000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addsub_in_compare1116	= { FOLLOW_addsub_in_compare1116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_compare1122  */
static	ANTLR3_BITWORD FOLLOW_37_in_compare1122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_compare1122	= { FOLLOW_37_in_compare1122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addsub_in_compare1126  */
static	ANTLR3_BITWORD FOLLOW_addsub_in_compare1126_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addsub_in_compare1126	= { FOLLOW_addsub_in_compare1126_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_compare1140  */
static	ANTLR3_BITWORD FOLLOW_38_in_compare1140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_compare1140	= { FOLLOW_38_in_compare1140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addsub_in_compare1144  */
static	ANTLR3_BITWORD FOLLOW_addsub_in_compare1144_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addsub_in_compare1144	= { FOLLOW_addsub_in_compare1144_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_compare1157  */
static	ANTLR3_BITWORD FOLLOW_39_in_compare1157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_compare1157	= { FOLLOW_39_in_compare1157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addsub_in_compare1161  */
static	ANTLR3_BITWORD FOLLOW_addsub_in_compare1161_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addsub_in_compare1161	= { FOLLOW_addsub_in_compare1161_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_compare1174  */
static	ANTLR3_BITWORD FOLLOW_39_in_compare1174_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_compare1174	= { FOLLOW_39_in_compare1174_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_compare1176  */
static	ANTLR3_BITWORD FOLLOW_37_in_compare1176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_compare1176	= { FOLLOW_37_in_compare1176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addsub_in_compare1180  */
static	ANTLR3_BITWORD FOLLOW_addsub_in_compare1180_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addsub_in_compare1180	= { FOLLOW_addsub_in_compare1180_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_compare1193  */
static	ANTLR3_BITWORD FOLLOW_40_in_compare1193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_compare1193	= { FOLLOW_40_in_compare1193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addsub_in_compare1197  */
static	ANTLR3_BITWORD FOLLOW_addsub_in_compare1197_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addsub_in_compare1197	= { FOLLOW_addsub_in_compare1197_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_compare1210  */
static	ANTLR3_BITWORD FOLLOW_40_in_compare1210_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_compare1210	= { FOLLOW_40_in_compare1210_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_compare1212  */
static	ANTLR3_BITWORD FOLLOW_37_in_compare1212_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_compare1212	= { FOLLOW_37_in_compare1212_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addsub_in_compare1216  */
static	ANTLR3_BITWORD FOLLOW_addsub_in_compare1216_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addsub_in_compare1216	= { FOLLOW_addsub_in_compare1216_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compare_in_expression1256  */
static	ANTLR3_BITWORD FOLLOW_compare_in_expression1256_bits[]	= { ANTLR3_UINT64_LIT(0x0000060000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compare_in_expression1256	= { FOLLOW_compare_in_expression1256_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_expression1265  */
static	ANTLR3_BITWORD FOLLOW_41_in_expression1265_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_expression1265	= { FOLLOW_41_in_expression1265_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compare_in_expression1269  */
static	ANTLR3_BITWORD FOLLOW_compare_in_expression1269_bits[]	= { ANTLR3_UINT64_LIT(0x0000060000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compare_in_expression1269	= { FOLLOW_compare_in_expression1269_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_expression1283  */
static	ANTLR3_BITWORD FOLLOW_42_in_expression1283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000380002070) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_expression1283	= { FOLLOW_42_in_expression1283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compare_in_expression1287  */
static	ANTLR3_BITWORD FOLLOW_compare_in_expression1287_bits[]	= { ANTLR3_UINT64_LIT(0x0000060000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compare_in_expression1287	= { FOLLOW_compare_in_expression1287_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_type0  */
static	ANTLR3_BITWORD FOLLOW_set_in_type0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_type0	= { FOLLOW_set_in_type0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiType_in_guiDecStatement1343  */
static	ANTLR3_BITWORD FOLLOW_guiType_in_guiDecStatement1343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_guiType_in_guiDecStatement1343	= { FOLLOW_guiType_in_guiDecStatement1343_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_12_in_guiDecStatement1345  */
static	ANTLR3_BITWORD FOLLOW_12_in_guiDecStatement1345_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_12_in_guiDecStatement1345	= { FOLLOW_12_in_guiDecStatement1345_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_guiDecStatement1349  */
static	ANTLR3_BITWORD FOLLOW_ID_in_guiDecStatement1349_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_guiDecStatement1349	= { FOLLOW_ID_in_guiDecStatement1349_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_guiDecStatement1359  */
static	ANTLR3_BITWORD FOLLOW_18_in_guiDecStatement1359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_guiDecStatement1359	= { FOLLOW_18_in_guiDecStatement1359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_guiTerm1379  */
static	ANTLR3_BITWORD FOLLOW_ID_in_guiTerm1379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_guiTerm1379	= { FOLLOW_ID_in_guiTerm1379_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_guiTerm1386  */
static	ANTLR3_BITWORD FOLLOW_13_in_guiTerm1386_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002010) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_guiTerm1386	= { FOLLOW_13_in_guiTerm1386_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiPositionExpression_in_guiTerm1388  */
static	ANTLR3_BITWORD FOLLOW_guiPositionExpression_in_guiTerm1388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_guiPositionExpression_in_guiTerm1388	= { FOLLOW_guiPositionExpression_in_guiTerm1388_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_guiTerm1390  */
static	ANTLR3_BITWORD FOLLOW_14_in_guiTerm1390_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_guiTerm1390	= { FOLLOW_14_in_guiTerm1390_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiTerm_in_guiPositionExpression1414  */
static	ANTLR3_BITWORD FOLLOW_guiTerm_in_guiPositionExpression1414_bits[]	= { ANTLR3_UINT64_LIT(0x07E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_guiTerm_in_guiPositionExpression1414	= { FOLLOW_guiTerm_in_guiPositionExpression1414_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_positionKeyword_in_guiPositionExpression1421  */
static	ANTLR3_BITWORD FOLLOW_positionKeyword_in_guiPositionExpression1421_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002010) };
static  ANTLR3_BITSET_LIST FOLLOW_positionKeyword_in_guiPositionExpression1421	= { FOLLOW_positionKeyword_in_guiPositionExpression1421_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiTerm_in_guiPositionExpression1425  */
static	ANTLR3_BITWORD FOLLOW_guiTerm_in_guiPositionExpression1425_bits[]	= { ANTLR3_UINT64_LIT(0x07E0000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_guiTerm_in_guiPositionExpression1425	= { FOLLOW_guiTerm_in_guiPositionExpression1425_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_guiComparisonExpression1456  */
static	ANTLR3_BITWORD FOLLOW_ID_in_guiComparisonExpression1456_bits[]	= { ANTLR3_UINT64_LIT(0x3800000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_guiComparisonExpression1456	= { FOLLOW_ID_in_guiComparisonExpression1456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiComparsionTerm_in_guiComparisonExpression1459  */
static	ANTLR3_BITWORD FOLLOW_guiComparsionTerm_in_guiComparisonExpression1459_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_guiComparsionTerm_in_guiComparisonExpression1459	= { FOLLOW_guiComparsionTerm_in_guiComparisonExpression1459_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_guiComparisonExpression1464  */
static	ANTLR3_BITWORD FOLLOW_ID_in_guiComparisonExpression1464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_guiComparisonExpression1464	= { FOLLOW_ID_in_guiComparisonExpression1464_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiDecStatement_in_guiStatement1489  */
static	ANTLR3_BITWORD FOLLOW_guiDecStatement_in_guiStatement1489_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_guiDecStatement_in_guiStatement1489	= { FOLLOW_guiDecStatement_in_guiStatement1489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiPositionExpression_in_guiStatement1498  */
static	ANTLR3_BITWORD FOLLOW_guiPositionExpression_in_guiStatement1498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_guiPositionExpression_in_guiStatement1498	= { FOLLOW_guiPositionExpression_in_guiStatement1498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_guiStatement1506  */
static	ANTLR3_BITWORD FOLLOW_18_in_guiStatement1506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_guiStatement1506	= { FOLLOW_18_in_guiStatement1506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_guiComparisonExpression_in_guiStatement1511  */
static	ANTLR3_BITWORD FOLLOW_guiComparisonExpression_in_guiStatement1511_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_guiComparisonExpression_in_guiStatement1511	= { FOLLOW_guiComparisonExpression_in_guiStatement1511_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_guiStatement1518  */
static	ANTLR3_BITWORD FOLLOW_18_in_guiStatement1518_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_guiStatement1518	= { FOLLOW_18_in_guiStatement1518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_evntHandleStatement1538  */
static	ANTLR3_BITWORD FOLLOW_ID_in_evntHandleStatement1538_bits[]	= { ANTLR3_UINT64_LIT(0x0000400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_evntHandleStatement1538	= { FOLLOW_ID_in_evntHandleStatement1538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_evntHandleStatement1540  */
static	ANTLR3_BITWORD FOLLOW_46_in_evntHandleStatement1540_bits[]	= { ANTLR3_UINT64_LIT(0x0018000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_evntHandleStatement1540	= { FOLLOW_46_in_evntHandleStatement1540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_eventType_in_evntHandleStatement1542  */
static	ANTLR3_BITWORD FOLLOW_eventType_in_evntHandleStatement1542_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_eventType_in_evntHandleStatement1542	= { FOLLOW_eventType_in_evntHandleStatement1542_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_13_in_evntHandleStatement1549  */
static	ANTLR3_BITWORD FOLLOW_13_in_evntHandleStatement1549_bits[]	= { ANTLR3_UINT64_LIT(0x0007800002756810) };
static  ANTLR3_BITSET_LIST FOLLOW_13_in_evntHandleStatement1549	= { FOLLOW_13_in_evntHandleStatement1549_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_evntHandleStatement1554  */
static	ANTLR3_BITWORD FOLLOW_statement_in_evntHandleStatement1554_bits[]	= { ANTLR3_UINT64_LIT(0x0007800002756810) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_evntHandleStatement1554	= { FOLLOW_statement_in_evntHandleStatement1554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_14_in_evntHandleStatement1565  */
static	ANTLR3_BITWORD FOLLOW_14_in_evntHandleStatement1565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_14_in_evntHandleStatement1565	= { FOLLOW_14_in_evntHandleStatement1565_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_18_in_evntHandleStatement1567  */
static	ANTLR3_BITWORD FOLLOW_18_in_evntHandleStatement1567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_18_in_evntHandleStatement1567	= { FOLLOW_18_in_evntHandleStatement1567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_guiType0  */
static	ANTLR3_BITWORD FOLLOW_set_in_guiType0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_guiType0	= { FOLLOW_set_in_guiType0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_eventType0  */
static	ANTLR3_BITWORD FOLLOW_set_in_eventType0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_eventType0	= { FOLLOW_set_in_eventType0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_positionKeyword0  */
static	ANTLR3_BITWORD FOLLOW_set_in_positionKeyword0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_positionKeyword0	= { FOLLOW_set_in_positionKeyword0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_guiComparsionTerm0  */
static	ANTLR3_BITWORD FOLLOW_set_in_guiComparsionTerm0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_guiComparsionTerm0	= { FOLLOW_set_in_guiComparsionTerm0_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start program
 * Guolice.g:164:1: program : ( procedureDec | functionDec | statement )* ;
 */
static void
program(pGuoliceParser ctx)
{   
    Node* statement1;
    #undef	RETURN_TYPE_statement1
    #define	RETURN_TYPE_statement1 Node*

    /* Initialize rule variables
     */


     root = new Node("PROGRAM"); 
    statement1 = NULL;

    {
        // Guolice.g:244:2: ( ( procedureDec | functionDec | statement )* )
        // Guolice.g:244:4: ( procedureDec | functionDec | statement )*
        {

            // Guolice.g:244:4: ( procedureDec | functionDec | statement )*

            for (;;)
            {
                int alt1=4;
                switch ( LA(1) ) 
                {
                case 11:
                	{
                		alt1=1;
                	}
                    break;
                case 16:
                	{
                		alt1=2;
                	}
                    break;
                case ID:
                case 13:
                case 18:
                case 20:
                case 21:
                case 22:
                case 25:
                case 47:
                case 48:
                case 49:
                case 50:
                	{
                		alt1=3;
                	}
                    break;

                }

                switch (alt1) 
                {
            	case 1:
            	    // Guolice.g:244:6: procedureDec
            	    {
            	        FOLLOWPUSH(FOLLOW_procedureDec_in_program69);
            	        procedureDec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprogramEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Guolice.g:244:21: functionDec
            	    {
            	        FOLLOWPUSH(FOLLOW_functionDec_in_program73);
            	        functionDec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprogramEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // Guolice.g:244:35: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_program77);
            	        statement1=statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprogramEx;
            	        }

            	        {

            	            /**
            	            *	in the main program you can declare functions, procedures, or statements
            	            */

            	            		if(statement1 ->getValue() != "emptyMark") 
            	            		{
            	            			statements.push_back(statement1);
            	            		}

            	            		for(int i = 0; i < variableDeclNodes.size(); i++) 
            	            		{
            	                       		statements.push_back(variableDeclNodes[i]);
            	                        		//cout << "A variable declaration node is: " << variableDeclNodes[i]->toString() << endl;
            	            		}
            	            		for(int i = 0; i < guiDeclNodes.size(); i++) 
            	            		{
            	            			statements.push_back(guiDeclNodes[i]);
            	            			//cout << "A variable declaration node is: " << variableDeclNodes[i]->toString() << endl;
            	            		}
            	            		guiDeclNodes.clear();
            	            		variableDeclNodes.clear();
            	                 
            	        }

            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {


                    		vector<Node*>::iterator i;
                    		for (i = statements.begin(); i != statements.end(); ++i)
                    		{
                    			//cout << " " << *i;
                    			root->addChild(*i);
                    		}

                    		printTree(root);

                    		cout <<  "The list of functions is: \n" << endl;
                    		printFunctionList();
                    		
                    		//getDot("Graph.dot"); // Dump the dot output to a file

                    		ParseTree *pTree = new ParseTree(root);
                    		
                    		pTree->varIDs = variableIDs;
                    		
                    		ofstream dotFile; // Output file stream for the dot file.
                    		dotFile.open("Graph.dot");
                      		
                      		dotFile << "digraph GuoliceParseGraph  {\n";
                      		dotFile << "graph[ordering=out];\n";

                    		pTree->traverse(root); // Get the dot output.
                    		
                    		dotFile << "\n//-------------------- Node Declarations --------------------\n";	
                    		
                    		for(int i = 0; i < pTree->nodeDeclarations.size(); i++) {
                    			dotFile << pTree->nodeDeclarations[i];
                    		}
                    		
                    		dotFile << "\n//-------------------- Edge Declarations --------------------\n";
                    		
                    		for(int j = 0; j < pTree->edgeDeclarations.size(); j++) {
                    			dotFile << pTree->edgeDeclarations[j];
                    		}
                    		
                    		dotFile << "\n\n";
                    		/*
                    		for (int i=0; i < functionList.size(); i++) 
                    		{
                    			// TODO: Separate variableIDs from each other to separate the parsegraphs.
                    			
                    			ParseTree *functionParseTree = new ParseTree(functionList[i]);
                    			
                    			functionParseTree->varIDs = variableIDs;
                    		
                    			functionParseTree->traverse(functionList[i]);
                    			
                    			dotFile << "\n//-------------------- Node Declarations for Function " << functionList[i]->getValue() << "--------------------\n";	
                    		
                    			for(int i = 0; i < functionParseTree->nodeDeclarations.size(); i++) {
                    				dotFile << functionParseTree->nodeDeclarations[i];
                    			}
                    		
                    			dotFile << "\n//-------------------- Edge Declarations for Function " << functionList[i]->getValue() << "--------------------\n";
                    		
                    			for(int j = 0; j < functionParseTree->edgeDeclarations.size(); j++) {
                    				dotFile << functionParseTree->edgeDeclarations[j];
                    			}
                    			
                    			dotFile << "\n";
                    		}
                    		*/
                    		dotFile << "}";
                    		
                      		dotFile.close();
                    		
                    		cout << "\nNUMBER OF NODES: " << pTree->getNodeCount() << endl;
                    		/*FunctionNode* first = functionList.at(0);
                    		cout << "The first procedure is: " << first->toString() << endl;
                    		FunctionNode* second = functionList.at(1);
                    		cout << "The second procedure is: " << second->toString() << endl;*/
                    	   
                }
            }


    return ;
}
/* $ANTLR end program */

/** 
 * $ANTLR start procedureDec
 * Guolice.g:269:1: procedureDec : 'procedure' ':' ID '(' ( parameters )? ')' ( statement | exitStatement )* 'end' 'procedure' ;
 */
static void
procedureDec(pGuoliceParser ctx)
{   
    pANTLR3_COMMON_TOKEN    ID2;
    Node* statement3;
    #undef	RETURN_TYPE_statement3
    #define	RETURN_TYPE_statement3 Node*

    /* Initialize rule variables
     */


     FunctionNode* procedureNode;
    /** to declare the procedure use the syntax
    *******************************************
    *	procedure : ID ( <parameters> )
    *	<statemets> or <exit statement>
    *	end procedure
    *******************************************
    *	the parameters are optional and when using more than one parameter
    *	you should seperet them with ','
    *	when using parameters you should specify the type of the parameter
    *
    *	Ex: procedure : pro1 (int : param1 , int : param2)
    *		<statements>
    *		end procedure		
    */
     
    ID2       = NULL;
    statement3 = NULL;

    {
        // Guolice.g:287:2: ( 'procedure' ':' ID '(' ( parameters )? ')' ( statement | exitStatement )* 'end' 'procedure' )
        // Guolice.g:287:4: 'procedure' ':' ID '(' ( parameters )? ')' ( statement | exitStatement )* 'end' 'procedure'
        {
             MATCHT(11, &FOLLOW_11_in_procedureDec99); 
            if  (HASEXCEPTION())
            {
                goto ruleprocedureDecEx;
            }

             MATCHT(12, &FOLLOW_12_in_procedureDec101); 
            if  (HASEXCEPTION())
            {
                goto ruleprocedureDecEx;
            }

            ID2 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_procedureDec103); 
            if  (HASEXCEPTION())
            {
                goto ruleprocedureDecEx;
            }

            {
                 procedureNode = new FunctionNode((string)(char*)((ID2->getText(ID2))->chars)); 
            }
             MATCHT(13, &FOLLOW_13_in_procedureDec109); 
            if  (HASEXCEPTION())
            {
                goto ruleprocedureDecEx;
            }


            // Guolice.g:288:6: ( parameters )?
            {
                int alt2=2;
                switch ( LA(1) ) 
                {
                    case 43:
                    case 44:
                    case 45:
                    	{
                    		alt2=1;
                    	}
                        break;
                }

                switch (alt2) 
                {
            	case 1:
            	    // Guolice.g:288:7: parameters
            	    {
            	        FOLLOWPUSH(FOLLOW_parameters_in_procedureDec112);
            	        parameters(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedureDecEx;
            	        }

            	        {
            	             procedureNode->setParameters(functionParameters); 
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(14, &FOLLOW_14_in_procedureDec119); 
            if  (HASEXCEPTION())
            {
                goto ruleprocedureDecEx;
            }


            // Guolice.g:289:3: ( statement | exitStatement )*

            for (;;)
            {
                int alt3=3;
                switch ( LA(1) ) 
                {
                case ID:
                case 13:
                case 18:
                case 20:
                case 21:
                case 22:
                case 25:
                case 47:
                case 48:
                case 49:
                case 50:
                	{
                		alt3=1;
                	}
                    break;
                case 27:
                	{
                		alt3=2;
                	}
                    break;

                }

                switch (alt3) 
                {
            	case 1:
            	    // Guolice.g:289:5: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_procedureDec125);
            	        statement3=statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedureDecEx;
            	        }

            	        {

            	            			if(statement3 ->getValue() != "emptyMark") 
            	            			{
            	            				 procedureNode->addChild(statement3);
            	            			}
            	            /*			for(int i = 0; i < variableDeclNodes.size(); i++) 
            	            			{
            	            				procedureNode->addChild(variableDeclNodes[i]);
            	                       		}
            	                        		for(int i = 0; i < guiDeclNodes.size(); i++) 
            	            			{
            	            				procedureNode->addChild(guiDeclNodes[i]);
            	                        		}
            	            			
            	                        		guiDeclNodes.clear();
            	                        		variableDeclNodes.clear();*/
            	            	   	
            	        }

            	    }
            	    break;
            	case 2:
            	    // Guolice.g:307:5: exitStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_exitStatement_in_procedureDec137);
            	        exitStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedureDecEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */

            {

                			procedureNode->setReturnType("void");
                			functionList.push_back(procedureNode); 
                		
            }
             MATCHT(15, &FOLLOW_15_in_procedureDec148); 
            if  (HASEXCEPTION())
            {
                goto ruleprocedureDecEx;
            }

             MATCHT(11, &FOLLOW_11_in_procedureDec150); 
            if  (HASEXCEPTION())
            {
                goto ruleprocedureDecEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprocedureDecEx; /* Prevent compiler warnings */
    ruleprocedureDecEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end procedureDec */

/** 
 * $ANTLR start functionDec
 * Guolice.g:316:1: functionDec : 'function' type ':' ID '(' ( parameters )? ')' ( statement )* returnStatement 'end' 'function' ;
 */
static void
functionDec(pGuoliceParser ctx)
{   
    pANTLR3_COMMON_TOKEN    ID4;
    Node* statement5;
    #undef	RETURN_TYPE_statement5
    #define	RETURN_TYPE_statement5 Node*

    GuoliceParser_type_return type6;
    #undef	RETURN_TYPE_type6
    #define	RETURN_TYPE_type6 GuoliceParser_type_return

    /* Initialize rule variables
     */


     FunctionNode* functionNode; 
    /** to declare the function use the syntax
    *******************************************
    *	function <type> : ID ( <parameters> )
    *	<statemets>
    *	<return statement>
    *	end function
    *******************************************
    *	the parameters are optional and when using more than one parameter
    *	you should seperet them with ','
    *	when using parameters you should specify the type of the parameter
    *
    *	Ex: function int : FUNC1 (int : param1 , int : param2)
    *		<statements>
    *		return val1;
    *		end function		
    */

    ID4       = NULL;
    statement5 = NULL;

    {
        // Guolice.g:336:2: ( 'function' type ':' ID '(' ( parameters )? ')' ( statement )* returnStatement 'end' 'function' )
        // Guolice.g:336:4: 'function' type ':' ID '(' ( parameters )? ')' ( statement )* returnStatement 'end' 'function'
        {
             MATCHT(16, &FOLLOW_16_in_functionDec168); 
            if  (HASEXCEPTION())
            {
                goto rulefunctionDecEx;
            }

            FOLLOWPUSH(FOLLOW_type_in_functionDec170);
            type6=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDecEx;
            }

             MATCHT(12, &FOLLOW_12_in_functionDec172); 
            if  (HASEXCEPTION())
            {
                goto rulefunctionDecEx;
            }

            ID4 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_functionDec174); 
            if  (HASEXCEPTION())
            {
                goto rulefunctionDecEx;
            }

            {
                 functionNode = new FunctionNode((string)(char*)((ID4->getText(ID4))->chars)); 
            }
             MATCHT(13, &FOLLOW_13_in_functionDec180); 
            if  (HASEXCEPTION())
            {
                goto rulefunctionDecEx;
            }


            // Guolice.g:337:6: ( parameters )?
            {
                int alt4=2;
                switch ( LA(1) ) 
                {
                    case 43:
                    case 44:
                    case 45:
                    	{
                    		alt4=1;
                    	}
                        break;
                }

                switch (alt4) 
                {
            	case 1:
            	    // Guolice.g:337:7: parameters
            	    {
            	        FOLLOWPUSH(FOLLOW_parameters_in_functionDec183);
            	        parameters(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDecEx;
            	        }

            	        {
            	             functionNode->setParameters(functionParameters); 
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(14, &FOLLOW_14_in_functionDec190); 
            if  (HASEXCEPTION())
            {
                goto rulefunctionDecEx;
            }


            // Guolice.g:338:3: ( statement )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) ) 
                {
                case ID:
                case 13:
                case 18:
                case 20:
                case 21:
                case 22:
                case 25:
                case 47:
                case 48:
                case 49:
                case 50:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5) 
                {
            	case 1:
            	    // Guolice.g:338:5: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_functionDec198);
            	        statement5=statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefunctionDecEx;
            	        }

            	        {

            	            			if(statement5 ->getValue() != "emptyMark") 
            	            			{
            	            				functionNode->addChild(statement5);
            	            			}
            	            			for(int i = 0; i < variableDeclNodes.size(); i++) 
            	            			{
            	            				functionNode->addChild(variableDeclNodes[i]);
            	            			}
            	            			for(int i = 0; i < guiDeclNodes.size(); i++) 
            	            			{
            	            				functionNode->addChild(guiDeclNodes[i]);
            	            			}
            	            			
            	            			guiDeclNodes.clear();
            	            			variableDeclNodes.clear();
            	            	   	
            	        }

            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */

            FOLLOWPUSH(FOLLOW_returnStatement_in_functionDec208);
            returnStatement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDecEx;
            }

             MATCHT(15, &FOLLOW_15_in_functionDec213); 
            if  (HASEXCEPTION())
            {
                goto rulefunctionDecEx;
            }

             MATCHT(16, &FOLLOW_16_in_functionDec215); 
            if  (HASEXCEPTION())
            {
                goto rulefunctionDecEx;
            }

            {
                 functionNode->setReturnType((string)(char*)((STRSTREAM->toStringTT(STRSTREAM, type6.start, type6.stop))->chars));
                                       functionList.push_back(functionNode); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefunctionDecEx; /* Prevent compiler warnings */
    rulefunctionDecEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end functionDec */

/** 
 * $ANTLR start parameters
 * Guolice.g:360:1: parameters : t1= type ':' i1= ID ( ',' t2= type ':' i2= ID )* ;
 */
static void
parameters(pGuoliceParser ctx)
{   
    pANTLR3_COMMON_TOKEN    i1;
    pANTLR3_COMMON_TOKEN    i2;
    GuoliceParser_type_return t1;
    #undef	RETURN_TYPE_t1
    #define	RETURN_TYPE_t1 GuoliceParser_type_return

    GuoliceParser_type_return t2;
    #undef	RETURN_TYPE_t2
    #define	RETURN_TYPE_t2 GuoliceParser_type_return

    /* Initialize rule variables
     */


    i1       = NULL;
    i2       = NULL;

    {
        // Guolice.g:361:2: (t1= type ':' i1= ID ( ',' t2= type ':' i2= ID )* )
        // Guolice.g:361:4: t1= type ':' i1= ID ( ',' t2= type ':' i2= ID )*
        {
            FOLLOWPUSH(FOLLOW_type_in_parameters230);
            t1=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparametersEx;
            }

             MATCHT(12, &FOLLOW_12_in_parameters233); 
            if  (HASEXCEPTION())
            {
                goto ruleparametersEx;
            }

            i1 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_parameters237); 
            if  (HASEXCEPTION())
            {
                goto ruleparametersEx;
            }

            {
                 functionParameters[(string)(char*)((i1->getText(i1))->chars)]=(string)(char*)((STRSTREAM->toStringTT(STRSTREAM, t1.start, t1.stop))->chars);
            }

            // Guolice.g:363:4: ( ',' t2= type ':' i2= ID )*

            for (;;)
            {
                int alt6=2;
                switch ( LA(1) ) 
                {
                case 17:
                	{
                		alt6=1;
                	}
                    break;

                }

                switch (alt6) 
                {
            	case 1:
            	    // Guolice.g:363:6: ',' t2= type ':' i2= ID
            	    {
            	         MATCHT(17, &FOLLOW_17_in_parameters249); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparametersEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_type_in_parameters253);
            	        t2=type(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparametersEx;
            	        }

            	         MATCHT(12, &FOLLOW_12_in_parameters256); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparametersEx;
            	        }

            	        i2 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_parameters260); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparametersEx;
            	        }

            	        {
            	             functionParameters[(string)(char*)((i2->getText(i2))->chars)]=(string)(char*)((STRSTREAM->toStringTT(STRSTREAM, t2.start, t2.stop))->chars);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparametersEx; /* Prevent compiler warnings */
    ruleparametersEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end parameters */

/** 
 * $ANTLR start statement
 * Guolice.g:368:1: statement returns [Node* node] : ( ';' | assignmentStatement | constantDecStatement | variableDecStatement | ifStatement | whileStatement | procedureCallStatement | guiStatement | evntHandleStatement );
 */
static Node*
statement(pGuoliceParser ctx)
{   
    Node* node = NULL;

    Node* assignmentStatement7;
    #undef	RETURN_TYPE_assignmentStatement7
    #define	RETURN_TYPE_assignmentStatement7 Node*

    Node* constantDecStatement8;
    #undef	RETURN_TYPE_constantDecStatement8
    #define	RETURN_TYPE_constantDecStatement8 Node*

    Node* variableDecStatement9;
    #undef	RETURN_TYPE_variableDecStatement9
    #define	RETURN_TYPE_variableDecStatement9 Node*

    Node* ifStatement10;
    #undef	RETURN_TYPE_ifStatement10
    #define	RETURN_TYPE_ifStatement10 Node*

    Node * whileStatement11;
    #undef	RETURN_TYPE_whileStatement11
    #define	RETURN_TYPE_whileStatement11 Node *

    Node * procedureCallStatement12;
    #undef	RETURN_TYPE_procedureCallStatement12
    #define	RETURN_TYPE_procedureCallStatement12 Node *

    Node* guiStatement13;
    #undef	RETURN_TYPE_guiStatement13
    #define	RETURN_TYPE_guiStatement13 Node*

    Node* evntHandleStatement14;
    #undef	RETURN_TYPE_evntHandleStatement14
    #define	RETURN_TYPE_evntHandleStatement14 Node*

    /* Initialize rule variables
     */



    /** 
    *	the statemets could be assignment Statement, constant Decleration Statement,
    *	variable Decleration Statement, if Statement, while Statement, procedure Call Statement,
    *	gui Statement or event Handle Statement.
    *
    */

    assignmentStatement7 = NULL;
    constantDecStatement8 = NULL;
    variableDecStatement9 = NULL;
    ifStatement10 = NULL;
    whileStatement11 = NULL;
    procedureCallStatement12 = NULL;
    guiStatement13 = NULL;
    evntHandleStatement14 = NULL;

    {
        {
            //  Guolice.g:377:2: ( ';' | assignmentStatement | constantDecStatement | variableDecStatement | ifStatement | whileStatement | procedureCallStatement | guiStatement | evntHandleStatement )
            
            ANTLR3_UINT32 alt7;

            alt7=9;

            switch ( LA(1) ) 
            {
            case 18:
            	{
            		alt7=1;
            	}
                break;
            case ID:
            	{
            		switch ( LA(2) ) 
            		{
            		case 19:
            			{
            				alt7=2;
            			}
            		    break;
            		case 46:
            			{
            				alt7=9;
            			}
            		    break;
            		case 53:
            		case 54:
            		case 55:
            		case 56:
            		case 57:
            		case 58:
            		case 59:
            		case 60:
            		case 61:
            			{
            				alt7=8;
            			}
            		    break;
            		case 13:
            			{
            				alt7=7;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 7;
            		    EXCEPTION->state        = 2;


            		    goto rulestatementEx;
            		}

            	}
                break;
            case 20:
            	{
            		alt7=3;
            	}
                break;
            case 21:
            	{
            		alt7=4;
            	}
                break;
            case 22:
            	{
            		alt7=5;
            	}
                break;
            case 25:
            	{
            		alt7=6;
            	}
                break;
            case 13:
            case 47:
            case 48:
            case 49:
            case 50:
            	{
            		alt7=8;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 7;
                EXCEPTION->state        = 0;


                goto rulestatementEx;
            }

            switch (alt7) 
            {
        	case 1:
        	    // Guolice.g:377:4: ';'
        	    {
        	         MATCHT(18, &FOLLOW_18_in_statement291); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Guolice.g:378:4: assignmentStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_assignmentStatement_in_statement296);
        	        assignmentStatement7=assignmentStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        {
        	             node= assignmentStatement7;
        	        }

        	    }
        	    break;
        	case 3:
        	    // Guolice.g:380:4: constantDecStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_constantDecStatement_in_statement306);
        	        constantDecStatement8=constantDecStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        {
        	             node= constantDecStatement8;
        	        }

        	    }
        	    break;
        	case 4:
        	    // Guolice.g:382:4: variableDecStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_variableDecStatement_in_statement316);
        	        variableDecStatement9=variableDecStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        {
        	             node= variableDecStatement9;
        	        }

        	    }
        	    break;
        	case 5:
        	    // Guolice.g:384:4: ifStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_ifStatement_in_statement326);
        	        ifStatement10=ifStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        {
        	             node=ifStatement10; 
        	        }

        	    }
        	    break;
        	case 6:
        	    // Guolice.g:386:4: whileStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_whileStatement_in_statement337);
        	        whileStatement11=whileStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        {
        	             node= whileStatement11; 
        	        }

        	    }
        	    break;
        	case 7:
        	    // Guolice.g:388:4: procedureCallStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_procedureCallStatement_in_statement347);
        	        procedureCallStatement12=procedureCallStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        {
        	             node= procedureCallStatement12; 
        	        }

        	    }
        	    break;
        	case 8:
        	    // Guolice.g:390:4: guiStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_guiStatement_in_statement357);
        	        guiStatement13=guiStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        {
        	             node= guiStatement13; 
        	        }

        	    }
        	    break;
        	case 9:
        	    // Guolice.g:392:4: evntHandleStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_evntHandleStatement_in_statement367);
        	        evntHandleStatement14=evntHandleStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }

        	        {
        	             node= evntHandleStatement14; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end statement */

/** 
 * $ANTLR start assignmentStatement
 * Guolice.g:401:1: assignmentStatement returns [Node* node] : ID ':=' expression ';' ;
 */
static Node*
assignmentStatement(pGuoliceParser ctx)
{   
    Node* node = NULL;

    pANTLR3_COMMON_TOKEN    ID15;
    Node* expression16;
    #undef	RETURN_TYPE_expression16
    #define	RETURN_TYPE_expression16 Node*

    /* Initialize rule variables
     */



    /** 
    *	the  assignment Statement syntax is:
    ******************************************
    *	ID := <expression> ;
    ******************************************
    *	the assignment Statement ends with ;
    *	and the expression could be an integer or string
    *	or a mathmatical expression like 4+(5*2)
    *
    */

    ID15       = NULL;
    expression16 = NULL;

    {
        // Guolice.g:414:2: ( ID ':=' expression ';' )
        // Guolice.g:414:4: ID ':=' expression ';'
        {
            ID15 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_assignmentStatement396); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentStatementEx;
            }

             MATCHT(19, &FOLLOW_19_in_assignmentStatement398); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_assignmentStatement400);
            expression16=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignmentStatementEx;
            }

             MATCHT(18, &FOLLOW_18_in_assignmentStatement402); 
            if  (HASEXCEPTION())
            {
                goto ruleassignmentStatementEx;
            }

            {

                			Node* idNode = new Node((string)(char*)((ID15->getText(ID15))->chars));   // Create a node for the identifier
                			idNode->setType(Node::VAR); // Set this node as a variable node
                			
                			Node* equalsNode = new Node(":=");   // Create a node for the assignment symbol

                			// Now add the identifier node and the node returned by the expression rule to the assignment symbol node
                			equalsNode->addChild(idNode);

                			equalsNode->addChild(expression16);
                			equalsNode->setType(Node::OP);  // Set this node as an operation node (assignment)
                			
                			node= equalsNode;   // Return the assignment symbol node
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleassignmentStatementEx; /* Prevent compiler warnings */
    ruleassignmentStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end assignmentStatement */

/** 
 * $ANTLR start constantDecStatement
 * Guolice.g:431:1: constantDecStatement returns [Node* node] : 'constant' type ':' ID ':=' expression ';' ;
 */
static Node*
constantDecStatement(pGuoliceParser ctx)
{   
    Node* node = NULL;

    pANTLR3_COMMON_TOKEN    ID17;
    GuoliceParser_type_return type18;
    #undef	RETURN_TYPE_type18
    #define	RETURN_TYPE_type18 GuoliceParser_type_return

    Node* expression19;
    #undef	RETURN_TYPE_expression19
    #define	RETURN_TYPE_expression19 Node*

    /* Initialize rule variables
     */



    /** 
    *	the  constant Decleration Statement syntax is:
    ******************************************
    *	constant <type> : ID  := <expression> ; 
    ******************************************
    *	the constant Decleration Statement ends with ;
    *	and the expression could be an int or string
    *	or a mathmatical expression like 4+(5*2)
    *	the <type> could be int, bool or string.
    */

    ID17       = NULL;
    expression19 = NULL;

    {
        // Guolice.g:444:2: ( 'constant' type ':' ID ':=' expression ';' )
        // Guolice.g:444:4: 'constant' type ':' ID ':=' expression ';'
        {
             MATCHT(20, &FOLLOW_20_in_constantDecStatement426); 
            if  (HASEXCEPTION())
            {
                goto ruleconstantDecStatementEx;
            }

            FOLLOWPUSH(FOLLOW_type_in_constantDecStatement428);
            type18=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconstantDecStatementEx;
            }

             MATCHT(12, &FOLLOW_12_in_constantDecStatement430); 
            if  (HASEXCEPTION())
            {
                goto ruleconstantDecStatementEx;
            }

            ID17 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_constantDecStatement432); 
            if  (HASEXCEPTION())
            {
                goto ruleconstantDecStatementEx;
            }

             MATCHT(19, &FOLLOW_19_in_constantDecStatement435); 
            if  (HASEXCEPTION())
            {
                goto ruleconstantDecStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_constantDecStatement437);
            expression19=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconstantDecStatementEx;
            }

             MATCHT(18, &FOLLOW_18_in_constantDecStatement439); 
            if  (HASEXCEPTION())
            {
                goto ruleconstantDecStatementEx;
            }

            {

                			node= new Node(":=");

                			string constantText ("");
                			constantText += (string)(char*)((ID17->getText(ID17))->chars);
                			constantText += " ( ";
                			constantText += (string)(char*)((STRSTREAM->toStringTT(STRSTREAM, type18.start, type18.stop))->chars);
                			constantText += " constant ) ";
                			
                			Node * idNode = new Node(constantText);
                			idNode->setType(Node::VAR);
                			
                			variableIDs[idNode] = (string)(char*)((ID17->getText(ID17))->chars);
                			
                			node->addChild(idNode);
                			node->addChild(expression19);
                			
                			node->setType(Node::OP);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconstantDecStatementEx; /* Prevent compiler warnings */
    ruleconstantDecStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end constantDecStatement */

/** 
 * $ANTLR start variableDecStatement
 * Guolice.g:466:1: variableDecStatement returns [Node* node] : 'var' type ':' i1= ID ( ':=' e1= expression )? ';' ;
 */
static Node*
variableDecStatement(pGuoliceParser ctx)
{   
    Node* node = NULL;

    pANTLR3_COMMON_TOKEN    i1;
    Node* e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 Node*

    GuoliceParser_type_return type20;
    #undef	RETURN_TYPE_type20
    #define	RETURN_TYPE_type20 GuoliceParser_type_return

    /* Initialize rule variables
     */


     /*Node * temp;*/
    /** 
    *	the  variable Decleration Statement syntax is:
    ******************************************
    *	var <type> : ID  := <expression> ; 
    ******************************************
    *	the variable Decleration Statement ends with ;
    *	the expression is optional.
    *	the expression could be an int or string
    *	or a mathmatical expression like 4+(5*2)
    *	the <type> could be int, bool or string.
    */
     
    i1       = NULL;
    e1 = NULL;

    {
        // Guolice.g:480:2: ( 'var' type ':' i1= ID ( ':=' e1= expression )? ';' )
        // Guolice.g:480:4: 'var' type ':' i1= ID ( ':=' e1= expression )? ';'
        {
             MATCHT(21, &FOLLOW_21_in_variableDecStatement463); 
            if  (HASEXCEPTION())
            {
                goto rulevariableDecStatementEx;
            }

            FOLLOWPUSH(FOLLOW_type_in_variableDecStatement465);
            type20=type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevariableDecStatementEx;
            }

             MATCHT(12, &FOLLOW_12_in_variableDecStatement467); 
            if  (HASEXCEPTION())
            {
                goto rulevariableDecStatementEx;
            }

            i1 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_variableDecStatement471); 
            if  (HASEXCEPTION())
            {
                goto rulevariableDecStatementEx;
            }

            {

                			//string varText ("var ");
                			string varText ("") ;
                			varText += (string)(char*)((i1->getText(i1))->chars);
                			varText += " ( ";
                			varText += (string)(char*)((STRSTREAM->toStringTT(STRSTREAM, type20.start, type20.stop))->chars);
                			varText += " variable ) ";
                			

                			//temp = new Node(varText);
                			node= new Node (varText);
                			node->setType(Node::VAR);
                			
                			variableIDs[node] = (string)(char*)((i1->getText(i1))->chars);
                			
                	    
            }

            // Guolice.g:497:2: ( ':=' e1= expression )?
            {
                int alt8=2;
                switch ( LA(1) ) 
                {
                    case 19:
                    	{
                    		alt8=1;
                    	}
                        break;
                }

                switch (alt8) 
                {
            	case 1:
            	    // Guolice.g:497:3: ':=' e1= expression
            	    {
            	         MATCHT(19, &FOLLOW_19_in_variableDecStatement480); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableDecStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_expression_in_variableDecStatement484);
            	        e1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableDecStatementEx;
            	        }

            	        {

            	            			Node * equalsNode = new Node(":=");
            	            			equalsNode->setType(Node::OP);
            	            			
            	            			//equalsNode->addChild(temp);
            	            			equalsNode->addChild(node);
            	            			equalsNode->addChild(e1);
            	            			node= equalsNode;
            	            	    
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(18, &FOLLOW_18_in_variableDecStatement497); 
            if  (HASEXCEPTION())
            {
                goto rulevariableDecStatementEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevariableDecStatementEx; /* Prevent compiler warnings */
    rulevariableDecStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end variableDecStatement */

/** 
 * $ANTLR start ifStatement
 * Guolice.g:511:1: ifStatement returns [Node* node] : 'if' (e1= expression | e1= guiComparisonExpression | '(' e1= guiComparisonExpression ')' | e1= guiPositionExpression ) 'then' (s1= statement )* ( 'else' (s2= statement )* )? 'end' 'if' ;
 */
static Node*
ifStatement(pGuoliceParser ctx)
{   
    Node* node = NULL;

    Node* e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 Node*

    Node* s1;
    #undef	RETURN_TYPE_s1
    #define	RETURN_TYPE_s1 Node*

    Node* s2;
    #undef	RETURN_TYPE_s2
    #define	RETURN_TYPE_s2 Node*

    /* Initialize rule variables
     */


     Node* thenNode; Node* elseNode;
    /** 
    *	the  if Statement syntax is:
    ***********************************
    *	if <expression> then
    *	<statements>
    *	else
    *	<statements>
    *	end if
    ***********************************
    * 
    *	the expression is either a regular expression or gui Comparison Expression 
    *	or guiPositionExpression.
    *	the expression could be put between Parentheses. (i.e. (expression) )
    */
     
    e1 = NULL;
    s1 = NULL;
    s2 = NULL;

    {
        // Guolice.g:528:2: ( 'if' (e1= expression | e1= guiComparisonExpression | '(' e1= guiComparisonExpression ')' | e1= guiPositionExpression ) 'then' (s1= statement )* ( 'else' (s2= statement )* )? 'end' 'if' )
        // Guolice.g:528:4: 'if' (e1= expression | e1= guiComparisonExpression | '(' e1= guiComparisonExpression ')' | e1= guiPositionExpression ) 'then' (s1= statement )* ( 'else' (s2= statement )* )? 'end' 'if'
        {
             MATCHT(22, &FOLLOW_22_in_ifStatement517); 
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            // Guolice.g:528:9: (e1= expression | e1= guiComparisonExpression | '(' e1= guiComparisonExpression ')' | e1= guiPositionExpression )
            {
                int alt9=4;
                switch ( LA(1) ) 
                {
                case INTEGER:
                case STRING_LITERAL:
                case 31:
                case 32:
                case 33:
                	{
                		alt9=1;
                	}
                    break;
                case 13:
                	{
                		switch ( LA(2) ) 
                		{
                		case ID:
                			{
                				switch ( LA(3) ) 
                				{
                				case 13:
                				case 14:
                				case 32:
                				case 33:
                				case 34:
                				case 35:
                				case 36:
                				case 37:
                				case 38:
                				case 39:
                				case 40:
                				case 41:
                				case 42:
                					{
                						alt9=1;
                					}
                				    break;
                				case 59:
                				case 60:
                				case 61:
                					{
                						alt9=3;
                					}
                				    break;
                				case 53:
                				case 54:
                				case 55:
                				case 56:
                				case 57:
                				case 58:
                					{
                						alt9=4;
                					}
                				    break;

                				default:
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 9;
                				    EXCEPTION->state        = 8;


                				    goto ruleifStatementEx;
                				}

                			}
                		    break;
                		case INTEGER:
                		case STRING_LITERAL:
                		case 31:
                		case 32:
                		case 33:
                			{
                				alt9=1;
                			}
                		    break;
                		case 13:
                			{
                				switch ( LA(3) ) 
                				{
                				case ID:
                					{
                						alt9=1;
                					}
                				    break;
                				case 13:
                					{
                						alt9=1;
                					}
                				    break;
                				case INTEGER:
                				case STRING_LITERAL:
                				case 31:
                				case 32:
                				case 33:
                					{
                						alt9=1;
                					}
                				    break;

                				default:
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 9;
                				    EXCEPTION->state        = 13;


                				    goto ruleifStatementEx;
                				}

                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 9;
                		    EXCEPTION->state        = 5;


                		    goto ruleifStatementEx;
                		}

                	}
                    break;
                case ID:
                	{
                		switch ( LA(2) ) 
                		{
                		case 13:
                		case 23:
                		case 32:
                		case 33:
                		case 34:
                		case 35:
                		case 36:
                		case 37:
                		case 38:
                		case 39:
                		case 40:
                		case 41:
                		case 42:
                			{
                				alt9=1;
                			}
                		    break;
                		case 53:
                		case 54:
                		case 55:
                		case 56:
                		case 57:
                		case 58:
                			{
                				alt9=4;
                			}
                		    break;
                		case 59:
                		case 60:
                		case 61:
                			{
                				alt9=2;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 9;
                		    EXCEPTION->state        = 6;


                		    goto ruleifStatementEx;
                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 9;
                    EXCEPTION->state        = 0;


                    goto ruleifStatementEx;
                }

                switch (alt9) 
                {
            	case 1:
            	    // Guolice.g:528:10: e1= expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_ifStatement522);
            	        e1=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Guolice.g:528:26: e1= guiComparisonExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_guiComparisonExpression_in_ifStatement528);
            	        e1=guiComparisonExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }


            	    }
            	    break;
            	case 3:
            	    // Guolice.g:528:55: '(' e1= guiComparisonExpression ')'
            	    {
            	         MATCHT(13, &FOLLOW_13_in_ifStatement532); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_guiComparisonExpression_in_ifStatement536);
            	        e1=guiComparisonExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }

            	         MATCHT(14, &FOLLOW_14_in_ifStatement538); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }


            	    }
            	    break;
            	case 4:
            	    // Guolice.g:528:92: e1= guiPositionExpression
            	    {
            	        FOLLOWPUSH(FOLLOW_guiPositionExpression_in_ifStatement544);
            	        e1=guiPositionExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }


            	    }
            	    break;

                }
            }
             MATCHT(23, &FOLLOW_23_in_ifStatement548); 
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

            {

                			node= new Node("if");                      
                			node->setType(Node::OP);	 		     	 
                			node->addChild(e1);                  
                			thenNode = new Node("then");
                			thenNode->setType(Node::OP);
                			node->addChild(thenNode);
                		
            }

            // Guolice.g:537:2: (s1= statement )*

            for (;;)
            {
                int alt10=2;
                switch ( LA(1) ) 
                {
                case ID:
                case 13:
                case 18:
                case 20:
                case 21:
                case 22:
                case 25:
                case 47:
                case 48:
                case 49:
                case 50:
                	{
                		alt10=1;
                	}
                    break;

                }

                switch (alt10) 
                {
            	case 1:
            	    // Guolice.g:537:4: s1= statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_ifStatement560);
            	        s1=statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }

            	        {
            	             thenNode->addChild(s1); 
            	        }

            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


            // Guolice.g:539:2: ( 'else' (s2= statement )* )?
            {
                int alt12=2;
                switch ( LA(1) ) 
                {
                    case 24:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12) 
                {
            	case 1:
            	    // Guolice.g:539:4: 'else' (s2= statement )*
            	    {
            	         MATCHT(24, &FOLLOW_24_in_ifStatement571); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }

            	        {
            	             
            	            			elseNode = new Node("else");
            	            			elseNode->setType(Node::OP);
            	            	      		node->addChild(elseNode);
            	            	   	
            	        }

            	        // Guolice.g:545:2: (s2= statement )*

            	        for (;;)
            	        {
            	            int alt11=2;
            	            switch ( LA(1) ) 
            	            {
            	            case ID:
            	            case 13:
            	            case 18:
            	            case 20:
            	            case 21:
            	            case 22:
            	            case 25:
            	            case 47:
            	            case 48:
            	            case 49:
            	            case 50:
            	            	{
            	            		alt11=1;
            	            	}
            	                break;

            	            }

            	            switch (alt11) 
            	            {
            	        	case 1:
            	        	    // Guolice.g:545:3: s2= statement
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_statement_in_ifStatement584);
            	        	        s2=statement(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleifStatementEx;
            	        	        }

            	        	        {
            	        	             elseNode->addChild(s2); 
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop11;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop11: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }
             MATCHT(15, &FOLLOW_15_in_ifStatement595); 
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

             MATCHT(22, &FOLLOW_22_in_ifStatement597); 
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end ifStatement */

/** 
 * $ANTLR start whileStatement
 * Guolice.g:549:1: whileStatement returns [Node * node] : 'while' expression 'loop' ( statement | exitStatement )* 'end' 'loop' ;
 */
static Node *
whileStatement(pGuoliceParser ctx)
{   
    Node * node = NULL;

    Node* expression21;
    #undef	RETURN_TYPE_expression21
    #define	RETURN_TYPE_expression21 Node*

    Node* statement22;
    #undef	RETURN_TYPE_statement22
    #define	RETURN_TYPE_statement22 Node*

    /* Initialize rule variables
     */



    /** 
    *	the  while Statement syntax is:
    ***********************************
    *	while <expression> loop
    *	<statements>
    *	end loop
    ***********************************
    * 
    *	the expression is  a regular expression (i.e. int)
    *	or a mathmatical expression like ( iterator < 5 ) which can be valued as a boolean
    */

    expression21 = NULL;
    statement22 = NULL;

    {
        // Guolice.g:563:2: ( 'while' expression 'loop' ( statement | exitStatement )* 'end' 'loop' )
        // Guolice.g:563:4: 'while' expression 'loop' ( statement | exitStatement )* 'end' 'loop'
        {
             MATCHT(25, &FOLLOW_25_in_whileStatement616); 
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }

            {
                 node= new Node("while"); node->setType(Node::OP); 
            }
            FOLLOWPUSH(FOLLOW_expression_in_whileStatement623);
            expression21=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }

            {
                 node->addChild(expression21); 
            }
             MATCHT(26, &FOLLOW_26_in_whileStatement629); 
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            // Guolice.g:566:4: ( statement | exitStatement )*

            for (;;)
            {
                int alt13=3;
                switch ( LA(1) ) 
                {
                case ID:
                case 13:
                case 18:
                case 20:
                case 21:
                case 22:
                case 25:
                case 47:
                case 48:
                case 49:
                case 50:
                	{
                		alt13=1;
                	}
                    break;
                case 27:
                	{
                		alt13=2;
                	}
                    break;

                }

                switch (alt13) 
                {
            	case 1:
            	    // Guolice.g:566:6: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_whileStatement636);
            	        statement22=statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewhileStatementEx;
            	        }

            	        {
            	             node->addChild(statement22); 
            	        }

            	    }
            	    break;
            	case 2:
            	    // Guolice.g:566:56: exitStatement
            	    {
            	        FOLLOWPUSH(FOLLOW_exitStatement_in_whileStatement642);
            	        exitStatement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulewhileStatementEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop13;	/* break out of the loop */
            	    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */

             MATCHT(15, &FOLLOW_15_in_whileStatement649); 
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }

             MATCHT(26, &FOLLOW_26_in_whileStatement651); 
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewhileStatementEx; /* Prevent compiler warnings */
    rulewhileStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end whileStatement */

/** 
 * $ANTLR start procedureCallStatement
 * Guolice.g:570:1: procedureCallStatement returns [Node * node] : ID ( '(' actualParameters ')' | '(' ')' ) ';' ;
 */
static Node *
procedureCallStatement(pGuoliceParser ctx)
{   
    Node * node = NULL;

    pANTLR3_COMMON_TOKEN    ID23;
    GuoliceParser_actualParameters_return actualParameters24;
    #undef	RETURN_TYPE_actualParameters24
    #define	RETURN_TYPE_actualParameters24 GuoliceParser_actualParameters_return

    /* Initialize rule variables
     */



    /** 
    *	the  procedure Call Statement syntax is:
    ***********************************
    *	ID ( <parameters> );
    ***********************************
    * 	
    *	the parameters are optional and when using more than one parameter
    *	you should seperet them with ','
    *	and when calling the procedure we don't specify the type of the parameters.
    *
    */

    ID23       = NULL;

    {
        // Guolice.g:584:2: ( ID ( '(' actualParameters ')' | '(' ')' ) ';' )
        // Guolice.g:584:4: ID ( '(' actualParameters ')' | '(' ')' ) ';'
        {
            ID23 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_procedureCallStatement670); 
            if  (HASEXCEPTION())
            {
                goto ruleprocedureCallStatementEx;
            }


            // Guolice.g:584:8: ( '(' actualParameters ')' | '(' ')' )
            {
                int alt14=2;
                switch ( LA(1) ) 
                {
                case 13:
                	{
                		switch ( LA(2) ) 
                		{
                		case 14:
                			{
                				alt14=2;
                			}
                		    break;
                		case ID:
                		case INTEGER:
                		case STRING_LITERAL:
                		case 13:
                		case 31:
                		case 32:
                		case 33:
                			{
                				alt14=1;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 14;
                		    EXCEPTION->state        = 1;


                		    goto ruleprocedureCallStatementEx;
                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 14;
                    EXCEPTION->state        = 0;


                    goto ruleprocedureCallStatementEx;
                }

                switch (alt14) 
                {
            	case 1:
            	    // Guolice.g:584:9: '(' actualParameters ')'
            	    {
            	         MATCHT(13, &FOLLOW_13_in_procedureCallStatement674); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedureCallStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_actualParameters_in_procedureCallStatement676);
            	        actualParameters24=actualParameters(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedureCallStatementEx;
            	        }

            	         MATCHT(14, &FOLLOW_14_in_procedureCallStatement678); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedureCallStatementEx;
            	        }

            	        {

            	            			string procedureCallText ((string)(char*)((ID23->getText(ID23))->chars));
            	            			procedureCallText += " (";
            	            			procedureCallText += (string)(char*)((STRSTREAM->toStringTT(STRSTREAM, actualParameters24.start, actualParameters24.stop))->chars); 
            	            			procedureCallText += ")";

            	            			node= new Node(procedureCallText);
            	            			node->setType(Node::OP);
            	            			for(int i = 0; i < actualParameters24.node->getChildren().size(); i++) 
            	            			{
            	            				node->addChild(actualParameters24.node->getChildren().at(i));
            	            			}
            	            		
            	        }

            	    }
            	    break;
            	case 2:
            	    // Guolice.g:599:4: '(' ')'
            	    {
            	         MATCHT(13, &FOLLOW_13_in_procedureCallStatement689); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedureCallStatementEx;
            	        }

            	         MATCHT(14, &FOLLOW_14_in_procedureCallStatement691); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprocedureCallStatementEx;
            	        }

            	        {

            	            			string procedureCallText ((string)(char*)((ID23->getText(ID23))->chars));
            	            			procedureCallText += " ( )";
            	            			node= new Node(procedureCallText);
            	            			node->setType(Node::OP);
            	            		
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(18, &FOLLOW_18_in_procedureCallStatement701); 
            if  (HASEXCEPTION())
            {
                goto ruleprocedureCallStatementEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprocedureCallStatementEx; /* Prevent compiler warnings */
    ruleprocedureCallStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end procedureCallStatement */

/** 
 * $ANTLR start actualParameters
 * Guolice.g:610:1: actualParameters returns [Node * node] : e1= expression ( ',' e2= expression )* ;
 */
static GuoliceParser_actualParameters_return
actualParameters(pGuoliceParser ctx)
{   
    GuoliceParser_actualParameters_return retval;

    Node* e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 Node*

    Node* e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 Node*

    /* Initialize rule variables
     */


    e1 = NULL;
    e2 = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        // Guolice.g:611:2: (e1= expression ( ',' e2= expression )* )
        // Guolice.g:611:4: e1= expression ( ',' e2= expression )*
        {
            FOLLOWPUSH(FOLLOW_expression_in_actualParameters719);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleactualParametersEx;
            }

            {
                 
                			retval.node= new Node();
                			retval.node->addChild(e1);
                		
            }

            // Guolice.g:616:2: ( ',' e2= expression )*

            for (;;)
            {
                int alt15=2;
                switch ( LA(1) ) 
                {
                case 17:
                	{
                		alt15=1;
                	}
                    break;

                }

                switch (alt15) 
                {
            	case 1:
            	    // Guolice.g:616:3: ',' e2= expression
            	    {
            	         MATCHT(17, &FOLLOW_17_in_actualParameters728); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleactualParametersEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_expression_in_actualParameters732);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleactualParametersEx;
            	        }

            	        {

            	            			retval.node->addChild(e2);
            	            		
            	        }

            	    }
            	    break;

            	default:
            	    goto loop15;	/* break out of the loop */
            	    break;
                }
            }
            loop15: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleactualParametersEx; /* Prevent compiler warnings */
    ruleactualParametersEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end actualParameters */

/** 
 * $ANTLR start exitStatement
 * Guolice.g:622:1: exitStatement : ( 'exit' 'when' expression ';' | 'exit' 'now' ';' );
 */
static void
exitStatement(pGuoliceParser ctx)
{   
    /* Initialize rule variables
     */



    /** 
    *	the  exit Statement syntax is:
    ***********************************
    *	exit when <expression> ;
    ***********************************
    * 	OR
    ***********************************
    *	exit now ;
    ***********************************
    *	we use this statement inside while statement
    *
    */

    {
        {
            //  Guolice.g:637:2: ( 'exit' 'when' expression ';' | 'exit' 'now' ';' )
            
            ANTLR3_UINT32 alt16;

            alt16=2;

            switch ( LA(1) ) 
            {
            case 27:
            	{
            		switch ( LA(2) ) 
            		{
            		case 28:
            			{
            				alt16=1;
            			}
            		    break;
            		case 29:
            			{
            				alt16=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 16;
            		    EXCEPTION->state        = 1;


            		    goto ruleexitStatementEx;
            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto ruleexitStatementEx;
            }

            switch (alt16) 
            {
        	case 1:
        	    // Guolice.g:637:4: 'exit' 'when' expression ';'
        	    {
        	         MATCHT(27, &FOLLOW_27_in_exitStatement754); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexitStatementEx;
        	        }

        	         MATCHT(28, &FOLLOW_28_in_exitStatement755); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexitStatementEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_exitStatement757);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexitStatementEx;
        	        }

        	         MATCHT(18, &FOLLOW_18_in_exitStatement759); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexitStatementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Guolice.g:638:4: 'exit' 'now' ';'
        	    {
        	         MATCHT(27, &FOLLOW_27_in_exitStatement764); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexitStatementEx;
        	        }

        	         MATCHT(29, &FOLLOW_29_in_exitStatement765); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexitStatementEx;
        	        }

        	         MATCHT(18, &FOLLOW_18_in_exitStatement766); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexitStatementEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexitStatementEx; /* Prevent compiler warnings */
    ruleexitStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end exitStatement */

/** 
 * $ANTLR start returnStatement
 * Guolice.g:641:1: returnStatement : 'return' expression ';' ;
 */
static void
returnStatement(pGuoliceParser ctx)
{   
    /* Initialize rule variables
     */



    /** 
    *	the  return Statement syntax is:
    ***********************************
    *	return <expression> ;
    ***********************************
    *	we use this statement inside the function declaration
    *
    */

    {
        // Guolice.g:652:2: ( 'return' expression ';' )
        // Guolice.g:652:4: 'return' expression ';'
        {
             MATCHT(30, &FOLLOW_30_in_returnStatement781); 
            if  (HASEXCEPTION())
            {
                goto rulereturnStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_returnStatement783);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulereturnStatementEx;
            }

             MATCHT(18, &FOLLOW_18_in_returnStatement785); 
            if  (HASEXCEPTION())
            {
                goto rulereturnStatementEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulereturnStatementEx; /* Prevent compiler warnings */
    rulereturnStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end returnStatement */

/** 
 * $ANTLR start term
 * Guolice.g:655:1: term returns [Node * node] : ( INTEGER | '(' expression ')' | ID | ID '(' actualParameters ')' | ID '(' ')' | STRING_LITERAL );
 */
static Node *
term(pGuoliceParser ctx)
{   
    Node * node = NULL;

    pANTLR3_COMMON_TOKEN    INTEGER25;
    pANTLR3_COMMON_TOKEN    ID27;
    pANTLR3_COMMON_TOKEN    ID29;
    pANTLR3_COMMON_TOKEN    ID30;
    pANTLR3_COMMON_TOKEN    STRING_LITERAL31;
    Node* expression26;
    #undef	RETURN_TYPE_expression26
    #define	RETURN_TYPE_expression26 Node*

    GuoliceParser_actualParameters_return actualParameters28;
    #undef	RETURN_TYPE_actualParameters28
    #define	RETURN_TYPE_actualParameters28 GuoliceParser_actualParameters_return

    /* Initialize rule variables
     */


     string tempText (""); 
    INTEGER25       = NULL;
    ID27       = NULL;
    ID29       = NULL;
    ID30       = NULL;
    STRING_LITERAL31       = NULL;
    expression26 = NULL;

    {
        {
            //  Guolice.g:657:2: ( INTEGER | '(' expression ')' | ID | ID '(' actualParameters ')' | ID '(' ')' | STRING_LITERAL )
            
            ANTLR3_UINT32 alt17;

            alt17=6;

            switch ( LA(1) ) 
            {
            case INTEGER:
            	{
            		alt17=1;
            	}
                break;
            case 13:
            	{
            		alt17=2;
            	}
                break;
            case ID:
            	{
            		switch ( LA(2) ) 
            		{
            		case 13:
            			{
            				switch ( LA(3) ) 
            				{
            				case 14:
            					{
            						alt17=5;
            					}
            				    break;
            				case ID:
            				case INTEGER:
            				case STRING_LITERAL:
            				case 13:
            				case 31:
            				case 32:
            				case 33:
            					{
            						alt17=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 17;
            				    EXCEPTION->state        = 5;


            				    goto ruletermEx;
            				}

            			}
            		    break;
            		case 14:
            		case 17:
            		case 18:
            		case 23:
            		case 26:
            		case 32:
            		case 33:
            		case 34:
            		case 35:
            		case 36:
            		case 37:
            		case 38:
            		case 39:
            		case 40:
            		case 41:
            		case 42:
            			{
            				alt17=3;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 17;
            		    EXCEPTION->state        = 3;


            		    goto ruletermEx;
            		}

            	}
                break;
            case STRING_LITERAL:
            	{
            		alt17=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 17;
                EXCEPTION->state        = 0;


                goto ruletermEx;
            }

            switch (alt17) 
            {
        	case 1:
        	    // Guolice.g:657:4: INTEGER
        	    {
        	        INTEGER25 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER, &FOLLOW_INTEGER_in_term805); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	        {
        	             node= new Node((string)(char*)((INTEGER25->getText(INTEGER25))->chars));
        	            		  node->setType(Node::CONST); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // Guolice.g:660:4: '(' expression ')'
        	    {
        	         MATCHT(13, &FOLLOW_13_in_term815); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_term817);
        	        expression26=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	         MATCHT(14, &FOLLOW_14_in_term819); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	        {
        	             node= expression26; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // Guolice.g:662:4: ID
        	    {
        	        ID27 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_term829); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	        {
        	             node= new Node((string)(char*)((ID27->getText(ID27))->chars)); node->setType(Node::VAR); 
        	        }

        	    }
        	    break;
        	case 4:
        	    // Guolice.g:664:4: ID '(' actualParameters ')'
        	    {
        	        ID29 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_term839); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	         MATCHT(13, &FOLLOW_13_in_term841); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_actualParameters_in_term843);
        	        actualParameters28=actualParameters(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	         MATCHT(14, &FOLLOW_14_in_term845); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	        {
        	             	tempText = (string)(char*)((STRSTREAM->toStringTT(STRSTREAM, actualParameters28.start, actualParameters28.stop))->chars);    
        	            			string nodeText ((string)(char*)((ID29->getText(ID29))->chars));
        	            			nodeText += "(";
        	            			nodeText += tempText;
        	            			nodeText += ")";
        	            			node= new Node(nodeText);
        	            			node->setType(Node::OP);
        	            			
        	            			for(int i = 0; i < actualParameters28.node->getChildren().size(); i++) 
        	            			{
        	            				node->addChild(actualParameters28.node->getChildren().at(i));
        	            			}
        	            		
        	        }

        	    }
        	    break;
        	case 5:
        	    // Guolice.g:678:4: ID '(' ')'
        	    {
        	        ID30 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_term855); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	         MATCHT(13, &FOLLOW_13_in_term857); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	         MATCHT(14, &FOLLOW_14_in_term859); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	        {
        	             	string nodeText ((string)(char*)((ID30->getText(ID30))->chars));
        	            			nodeText += "( )";
        	            			node= new Node(nodeText);
        	            			node->setType(Node::OP);
        	            		
        	        }

        	    }
        	    break;
        	case 6:
        	    // Guolice.g:684:4: STRING_LITERAL
        	    {
        	        STRING_LITERAL31 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_term869); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermEx;
        	        }

        	        {

        	            		string nodeText ((string)(char*)((STRING_LITERAL31->getText(STRING_LITERAL31))->chars));
        	            		nodeText = nodeText.substr(1, nodeText.length() - 2);
        	            		node= new Node(nodeText); node->setType(Node::CONST); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end term */

/** 
 * $ANTLR start negation
 * Guolice.g:693:1: negation returns [Node * node] : ( 'NOT' )* term ;
 */
static Node *
negation(pGuoliceParser ctx)
{   
    Node * node = NULL;

    Node * term32;
    #undef	RETURN_TYPE_term32
    #define	RETURN_TYPE_term32 Node *

    /* Initialize rule variables
     */


     int numberOfNots = 0; 
    term32 = NULL;

    {
        // Guolice.g:695:2: ( ( 'NOT' )* term )
        // Guolice.g:695:4: ( 'NOT' )* term
        {

            // Guolice.g:695:4: ( 'NOT' )*

            for (;;)
            {
                int alt18=2;
                switch ( LA(1) ) 
                {
                case 31:
                	{
                		alt18=1;
                	}
                    break;

                }

                switch (alt18) 
                {
            	case 1:
            	    // Guolice.g:695:6: 'NOT'
            	    {
            	         MATCHT(31, &FOLLOW_31_in_negation897); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenegationEx;
            	        }

            	        {
            	             numberOfNots++; 
            	        }

            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */

            FOLLOWPUSH(FOLLOW_term_in_negation904);
            term32=term(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenegationEx;
            }

            {

                			Node * returnNode = term32;

                			for(int i = 0; i < numberOfNots; i++) 
                			{
                				Node * notNode = new Node("NOT");
                				notNode->setType(Node::OP);
                				notNode->addChild(returnNode);
                				
                				returnNode = notNode;
                			}

                			node= returnNode;
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenegationEx; /* Prevent compiler warnings */
    rulenegationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end negation */

/** 
 * $ANTLR start unary
 * Guolice.g:712:1: unary returns [Node * node] : ( '+' | '-' )* negation ;
 */
static Node *
unary(pGuoliceParser ctx)
{   
    Node * node = NULL;

    Node * negation33;
    #undef	RETURN_TYPE_negation33
    #define	RETURN_TYPE_negation33 Node *

    /* Initialize rule variables
     */


     int minuses = 0; 
    negation33 = NULL;

    {
        // Guolice.g:714:2: ( ( '+' | '-' )* negation )
        // Guolice.g:714:4: ( '+' | '-' )* negation
        {

            // Guolice.g:714:4: ( '+' | '-' )*

            for (;;)
            {
                int alt19=3;
                switch ( LA(1) ) 
                {
                case 32:
                	{
                		alt19=1;
                	}
                    break;
                case 33:
                	{
                		alt19=2;
                	}
                    break;

                }

                switch (alt19) 
                {
            	case 1:
            	    // Guolice.g:714:6: '+'
            	    {
            	         MATCHT(32, &FOLLOW_32_in_unary930); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunaryEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Guolice.g:714:12: '-'
            	    {
            	         MATCHT(33, &FOLLOW_33_in_unary934); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunaryEx;
            	        }

            	        {
            	             minuses++; 
            	        }

            	    }
            	    break;

            	default:
            	    goto loop19;	/* break out of the loop */
            	    break;
                }
            }
            loop19: ; /* Jump out to here if this rule does not match */

            FOLLOWPUSH(FOLLOW_negation_in_unary940);
            negation33=negation(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleunaryEx;
            }

            {

                		string sign = (minuses % 2 == 0)? "" : "-";  // if number of minuses is even, the sign is "", otherwise the sign is -
                		if (minuses % 2 == 0)
                			{	
                				node= negation33;
                			}

                		else
                			{			
                				node= new Node("-");  // Why the heck would we need a labeled node for a minus sign?
                				node->setType(Node::OP);
                				node->addChild(negation33);			
                			}	
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleunaryEx; /* Prevent compiler warnings */
    ruleunaryEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end unary */

/** 
 * $ANTLR start multdiv
 * Guolice.g:730:1: multdiv returns [Node* node] : u1= unary ( ( '*' u2= unary ) | ( '/' u2= unary ) | ( 'MOD' u2= unary ) )* ;
 */
static Node*
multdiv(pGuoliceParser ctx)
{   
    Node* node = NULL;

    Node * u1;
    #undef	RETURN_TYPE_u1
    #define	RETURN_TYPE_u1 Node *

    Node * u2;
    #undef	RETURN_TYPE_u2
    #define	RETURN_TYPE_u2 Node *

    /* Initialize rule variables
     */



    		bool multExists = false;
    		bool divExists = false;
    		bool moduloExists = false;
    		Node* temp;
    	
    u1 = NULL;
    u2 = NULL;

    {
        // Guolice.g:738:2: (u1= unary ( ( '*' u2= unary ) | ( '/' u2= unary ) | ( 'MOD' u2= unary ) )* )
        // Guolice.g:738:4: u1= unary ( ( '*' u2= unary ) | ( '/' u2= unary ) | ( 'MOD' u2= unary ) )*
        {
            FOLLOWPUSH(FOLLOW_unary_in_multdiv966);
            u1=unary(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemultdivEx;
            }

            {
                 temp = u1; 
            }

            // Guolice.g:738:33: ( ( '*' u2= unary ) | ( '/' u2= unary ) | ( 'MOD' u2= unary ) )*

            for (;;)
            {
                int alt20=4;
                switch ( LA(1) ) 
                {
                case 34:
                	{
                		alt20=1;
                	}
                    break;
                case 35:
                	{
                		alt20=2;
                	}
                    break;
                case 36:
                	{
                		alt20=3;
                	}
                    break;

                }

                switch (alt20) 
                {
            	case 1:
            	    // Guolice.g:738:35: ( '*' u2= unary )
            	    {
            	        // Guolice.g:738:35: ( '*' u2= unary )
            	        // Guolice.g:738:37: '*' u2= unary
            	        {
            	             MATCHT(34, &FOLLOW_34_in_multdiv973); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemultdivEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_unary_in_multdiv977);
            	            u2=unary(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemultdivEx;
            	            }

            	            {

            	                			if(!multExists && !divExists && !moduloExists) 
            	                			{
            	                				multExists = true;
            	                			}

            	                			Node* multNode = new Node("*");
            	                			multNode->setType(Node::OP);
            	                			
            	                			multNode->addChild(temp);

            	                			multNode->addChild(u2);

            	                			temp = multNode;
            	                		
            	            }

            	        }


            	    }
            	    break;
            	case 2:
            	    // Guolice.g:754:4: ( '/' u2= unary )
            	    {
            	        // Guolice.g:754:4: ( '/' u2= unary )
            	        // Guolice.g:754:6: '/' u2= unary
            	        {
            	             MATCHT(35, &FOLLOW_35_in_multdiv989); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemultdivEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_unary_in_multdiv993);
            	            u2=unary(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemultdivEx;
            	            }

            	            {

            	                			if(!multExists && !divExists && !moduloExists) 
            	                			{
            	                				divExists = true;
            	                			}

            	                			Node* divNode = new Node("/");
            	                			divNode->setType(Node::OP);
            	                			
            	                			divNode->addChild(temp);

            	                			divNode->addChild(u2);

            	                			temp = divNode;
            	                		
            	            }

            	        }


            	    }
            	    break;
            	case 3:
            	    // Guolice.g:770:4: ( 'MOD' u2= unary )
            	    {
            	        // Guolice.g:770:4: ( 'MOD' u2= unary )
            	        // Guolice.g:770:6: 'MOD' u2= unary
            	        {
            	             MATCHT(36, &FOLLOW_36_in_multdiv1006); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemultdivEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_unary_in_multdiv1010);
            	            u2=unary(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemultdivEx;
            	            }

            	            {

            	                			if(!multExists && !divExists && !moduloExists) 
            	                			{
            	                				moduloExists = true;
            	                			}

            	                			Node* moduloNode = new Node("mod");
            	                			moduloNode->setType(Node::OP);
            	                			
            	                			moduloNode->addChild(temp);

            	                			moduloNode->addChild(u2);

            	                			temp = moduloNode;
            	                		
            	            }

            	        }


            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */

            {
                node= temp;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemultdivEx; /* Prevent compiler warnings */
    rulemultdivEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end multdiv */

/** 
 * $ANTLR start addsub
 * Guolice.g:792:1: addsub returns [Node* node] : m1= multdiv ( ( '+' m2= multdiv ) | ( '-' m2= multdiv ) )* ;
 */
static Node*
addsub(pGuoliceParser ctx)
{   
    Node* node = NULL;

    Node* m1;
    #undef	RETURN_TYPE_m1
    #define	RETURN_TYPE_m1 Node*

    Node* m2;
    #undef	RETURN_TYPE_m2
    #define	RETURN_TYPE_m2 Node*

    /* Initialize rule variables
     */



    			bool plusExists = false;
    			bool minusExists = false;
    			Node* temp;
    		
    m1 = NULL;
    m2 = NULL;

    {
        // Guolice.g:798:2: (m1= multdiv ( ( '+' m2= multdiv ) | ( '-' m2= multdiv ) )* )
        // Guolice.g:798:4: m1= multdiv ( ( '+' m2= multdiv ) | ( '-' m2= multdiv ) )*
        {
            FOLLOWPUSH(FOLLOW_multdiv_in_addsub1049);
            m1=multdiv(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaddsubEx;
            }

            {
                 temp = m1; 
            }

            // Guolice.g:798:35: ( ( '+' m2= multdiv ) | ( '-' m2= multdiv ) )*

            for (;;)
            {
                int alt21=3;
                switch ( LA(1) ) 
                {
                case 32:
                	{
                		alt21=1;
                	}
                    break;
                case 33:
                	{
                		alt21=2;
                	}
                    break;

                }

                switch (alt21) 
                {
            	case 1:
            	    // Guolice.g:798:37: ( '+' m2= multdiv )
            	    {
            	        // Guolice.g:798:37: ( '+' m2= multdiv )
            	        // Guolice.g:798:39: '+' m2= multdiv
            	        {
            	             MATCHT(32, &FOLLOW_32_in_addsub1056); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleaddsubEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_multdiv_in_addsub1060);
            	            m2=multdiv(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleaddsubEx;
            	            }

            	            {

            	                			if(!plusExists && !minusExists) 
            	                			{
            	                				plusExists = true;
            	                			}

            	                			Node* plusNode = new Node("+");
            	                			plusNode->setType(Node::OP);
            	                			
            	                			plusNode->addChild(temp);
            	                			plusNode->addChild(m2);
            	                			temp = plusNode;
            	                		
            	            }

            	        }


            	    }
            	    break;
            	case 2:
            	    // Guolice.g:812:4: ( '-' m2= multdiv )
            	    {
            	        // Guolice.g:812:4: ( '-' m2= multdiv )
            	        // Guolice.g:812:6: '-' m2= multdiv
            	        {
            	             MATCHT(33, &FOLLOW_33_in_addsub1073); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleaddsubEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_multdiv_in_addsub1077);
            	            m2=multdiv(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleaddsubEx;
            	            }

            	            {

            	                			if(!plusExists && !minusExists) 
            	                			{
            	                				minusExists = true;
            	                			}

            	                			Node* minusNode = new Node("-");
            	                			minusNode->setType(Node::OP);
            	                			
            	                			minusNode->addChild(temp);
            	                			minusNode->addChild(m2);
            	                			temp = minusNode;
            	                		
            	            }

            	        }


            	    }
            	    break;

            	default:
            	    goto loop21;	/* break out of the loop */
            	    break;
                }
            }
            loop21: ; /* Jump out to here if this rule does not match */

            {
                node= temp;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleaddsubEx; /* Prevent compiler warnings */
    ruleaddsubEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end addsub */

/** 
 * $ANTLR start compare
 * Guolice.g:831:1: compare returns [Node* node] : a1= addsub ( ( '=' a2= addsub ) | ( '!=' a2= addsub ) | ( '<' a2= addsub ) | ( '<' '=' a2= addsub ) | ( '>' a2= addsub ) | ( '>' '=' a2= addsub ) )? ;
 */
static Node*
compare(pGuoliceParser ctx)
{   
    Node* node = NULL;

    Node* a1;
    #undef	RETURN_TYPE_a1
    #define	RETURN_TYPE_a1 Node*

    Node* a2;
    #undef	RETURN_TYPE_a2
    #define	RETURN_TYPE_a2 Node*

    /* Initialize rule variables
     */


    bool comparatorExists = false;
    	Node* comparatorNode;

    a1 = NULL;
    a2 = NULL;

    {
        // Guolice.g:835:2: (a1= addsub ( ( '=' a2= addsub ) | ( '!=' a2= addsub ) | ( '<' a2= addsub ) | ( '<' '=' a2= addsub ) | ( '>' a2= addsub ) | ( '>' '=' a2= addsub ) )? )
        // Guolice.g:835:4: a1= addsub ( ( '=' a2= addsub ) | ( '!=' a2= addsub ) | ( '<' a2= addsub ) | ( '<' '=' a2= addsub ) | ( '>' a2= addsub ) | ( '>' '=' a2= addsub ) )?
        {
            FOLLOWPUSH(FOLLOW_addsub_in_compare1116);
            a1=addsub(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecompareEx;
            }


            // Guolice.g:835:14: ( ( '=' a2= addsub ) | ( '!=' a2= addsub ) | ( '<' a2= addsub ) | ( '<' '=' a2= addsub ) | ( '>' a2= addsub ) | ( '>' '=' a2= addsub ) )?
            {
                int alt22=7;
                switch ( LA(1) ) 
                {
                    case 37:
                    	{
                    		alt22=1;
                    	}
                        break;
                    case 38:
                    	{
                    		alt22=2;
                    	}
                        break;
                    case 39:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		    case 37:
                    		    	{
                    		    		alt22=4;
                    		    	}
                    		        break;
                    		    case ID:
                    		    case INTEGER:
                    		    case STRING_LITERAL:
                    		    case 13:
                    		    case 31:
                    		    case 32:
                    		    case 33:
                    		    	{
                    		    		alt22=3;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                    case 40:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		    case 37:
                    		    	{
                    		    		alt22=6;
                    		    	}
                    		        break;
                    		    case ID:
                    		    case INTEGER:
                    		    case STRING_LITERAL:
                    		    case 13:
                    		    case 31:
                    		    case 32:
                    		    case 33:
                    		    	{
                    		    		alt22=5;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt22) 
                {
            	case 1:
            	    // Guolice.g:835:16: ( '=' a2= addsub )
            	    {
            	        // Guolice.g:835:16: ( '=' a2= addsub )
            	        // Guolice.g:835:18: '=' a2= addsub
            	        {
            	             MATCHT(37, &FOLLOW_37_in_compare1122); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_addsub_in_compare1126);
            	            a2=addsub(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            {

            	                			comparatorNode = new Node("=");
            	                			
            	                			comparatorNode->addChild(a1);

            	                			comparatorNode->addChild(a2);

            	                			comparatorExists = true;
            	                		
            	            }

            	        }


            	    }
            	    break;
            	case 2:
            	    // Guolice.g:846:4: ( '!=' a2= addsub )
            	    {
            	        // Guolice.g:846:4: ( '!=' a2= addsub )
            	        // Guolice.g:846:6: '!=' a2= addsub
            	        {
            	             MATCHT(38, &FOLLOW_38_in_compare1140); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_addsub_in_compare1144);
            	            a2=addsub(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            {

            	                			comparatorNode = new Node("!=");
            	                			comparatorNode->addChild(a1);

            	                			comparatorNode->addChild(a2);

            	                			comparatorExists = true;
            	                		
            	            }

            	        }


            	    }
            	    break;
            	case 3:
            	    // Guolice.g:855:4: ( '<' a2= addsub )
            	    {
            	        // Guolice.g:855:4: ( '<' a2= addsub )
            	        // Guolice.g:855:6: '<' a2= addsub
            	        {
            	             MATCHT(39, &FOLLOW_39_in_compare1157); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_addsub_in_compare1161);
            	            a2=addsub(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            {

            	                			comparatorNode = new Node("<");
            	                			comparatorNode->addChild(a1);

            	                			comparatorNode->addChild(a2);

            	                			comparatorExists = true;
            	                		
            	            }

            	        }


            	    }
            	    break;
            	case 4:
            	    // Guolice.g:864:4: ( '<' '=' a2= addsub )
            	    {
            	        // Guolice.g:864:4: ( '<' '=' a2= addsub )
            	        // Guolice.g:864:6: '<' '=' a2= addsub
            	        {
            	             MATCHT(39, &FOLLOW_39_in_compare1174); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	             MATCHT(37, &FOLLOW_37_in_compare1176); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_addsub_in_compare1180);
            	            a2=addsub(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            {

            	                			comparatorNode = new Node("<=");
            	                			comparatorNode->addChild(a1);

            	                			comparatorNode->addChild(a2);

            	                			comparatorExists = true;
            	                		
            	            }

            	        }


            	    }
            	    break;
            	case 5:
            	    // Guolice.g:873:4: ( '>' a2= addsub )
            	    {
            	        // Guolice.g:873:4: ( '>' a2= addsub )
            	        // Guolice.g:873:6: '>' a2= addsub
            	        {
            	             MATCHT(40, &FOLLOW_40_in_compare1193); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_addsub_in_compare1197);
            	            a2=addsub(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            {

            	                			comparatorNode = new Node(">");
            	                			comparatorNode->addChild(a1);

            	                			comparatorNode->addChild(a2);

            	                			comparatorExists = true;
            	                		
            	            }

            	        }


            	    }
            	    break;
            	case 6:
            	    // Guolice.g:882:4: ( '>' '=' a2= addsub )
            	    {
            	        // Guolice.g:882:4: ( '>' '=' a2= addsub )
            	        // Guolice.g:882:6: '>' '=' a2= addsub
            	        {
            	             MATCHT(40, &FOLLOW_40_in_compare1210); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	             MATCHT(37, &FOLLOW_37_in_compare1212); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_addsub_in_compare1216);
            	            a2=addsub(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecompareEx;
            	            }

            	            {

            	                			comparatorNode = new Node(">=");
            	                			comparatorNode->addChild(a1);

            	                			comparatorNode->addChild(a2);

            	                			comparatorExists = true;
            	                		
            	            }

            	        }


            	    }
            	    break;

                }
            }
            {

                		if(comparatorExists) 
                		{
                			comparatorNode->setType(Node::OP);
                			node= comparatorNode;
                		}
                		else node= a1;
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecompareEx; /* Prevent compiler warnings */
    rulecompareEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end compare */

/** 
 * $ANTLR start expression
 * Guolice.g:904:1: expression returns [Node* node] : c1= compare ( ( 'AND' c2= compare ) | ( 'OR' c2= compare ) )* ;
 */
static Node*
expression(pGuoliceParser ctx)
{   
    Node* node = NULL;

    Node* c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 Node*

    Node* c2;
    #undef	RETURN_TYPE_c2
    #define	RETURN_TYPE_c2 Node*

    /* Initialize rule variables
     */



    		bool andExists = false;
    		bool orExists = false;
    		Node* temp;
    	
    c1 = NULL;
    c2 = NULL;

    {
        // Guolice.g:911:2: (c1= compare ( ( 'AND' c2= compare ) | ( 'OR' c2= compare ) )* )
        // Guolice.g:911:4: c1= compare ( ( 'AND' c2= compare ) | ( 'OR' c2= compare ) )*
        {
            FOLLOWPUSH(FOLLOW_compare_in_expression1256);
            c1=compare(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionEx;
            }

            {
                 temp = c1; 
            }

            // Guolice.g:912:2: ( ( 'AND' c2= compare ) | ( 'OR' c2= compare ) )*

            for (;;)
            {
                int alt23=3;
                switch ( LA(1) ) 
                {
                case 41:
                	{
                		alt23=1;
                	}
                    break;
                case 42:
                	{
                		alt23=2;
                	}
                    break;

                }

                switch (alt23) 
                {
            	case 1:
            	    // Guolice.g:912:4: ( 'AND' c2= compare )
            	    {
            	        // Guolice.g:912:4: ( 'AND' c2= compare )
            	        // Guolice.g:912:6: 'AND' c2= compare
            	        {
            	             MATCHT(41, &FOLLOW_41_in_expression1265); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleexpressionEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_compare_in_expression1269);
            	            c2=compare(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleexpressionEx;
            	            }

            	            {

            	                			if(!andExists && !orExists) 
            	                			{
            	                				andExists = true;
            	                			}

            	                		 	Node* andNode = new Node("AND");
            	                			andNode->setType(Node::OP);
            	                			
            	                		 	andNode->addChild(temp);
            	                	
            	                			andNode->addChild(c2);
            	                	
            	                			temp = andNode;
            	                		 
            	            }

            	        }


            	    }
            	    break;
            	case 2:
            	    // Guolice.g:929:4: ( 'OR' c2= compare )
            	    {
            	        // Guolice.g:929:4: ( 'OR' c2= compare )
            	        // Guolice.g:929:6: 'OR' c2= compare
            	        {
            	             MATCHT(42, &FOLLOW_42_in_expression1283); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleexpressionEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_compare_in_expression1287);
            	            c2=compare(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleexpressionEx;
            	            }

            	            {

            	                			if(!andExists && !orExists) 
            	                			{
            	                				orExists = true;
            	                			}

            	                		 	Node* orNode = new Node("OR");
            	                			orNode->setType(Node::OP);
            	                			
            	                		 	orNode->addChild(temp);

            	                			orNode->addChild(c2);

            	                			temp = orNode;
            	                		
            	            }

            	        }


            	    }
            	    break;

            	default:
            	    goto loop23;	/* break out of the loop */
            	    break;
                }
            }
            loop23: ; /* Jump out to here if this rule does not match */

            {
                 node= temp;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end expression */

/** 
 * $ANTLR start type
 * Guolice.g:949:1: type : ( 'int' | 'bool' | 'string' );
 */
static GuoliceParser_type_return
type(pGuoliceParser ctx)
{   
    GuoliceParser_type_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // Guolice.g:950:2: ( 'int' | 'bool' | 'string' )
        // Guolice.g:
        {
            if ( ((LA(1) >= 43) && (LA(1) <= 45)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_type0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_type0);    goto ruletypeEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletypeEx; /* Prevent compiler warnings */
    ruletypeEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end type */

/** 
 * $ANTLR start guiDecStatement
 * Guolice.g:956:1: guiDecStatement returns [Node* node] : guiType ':' i1= ID ';' ;
 */
static Node*
guiDecStatement(pGuoliceParser ctx)
{   
    Node* node = NULL;

    pANTLR3_COMMON_TOKEN    i1;
    GuoliceParser_guiType_return guiType34;
    #undef	RETURN_TYPE_guiType34
    #define	RETURN_TYPE_guiType34 GuoliceParser_guiType_return

    /* Initialize rule variables
     */


     /*Node* temp;*/
    /** 
    *	the  GUI Declaration Statement syntax is:
    ******************************************
    *	<guiType> : ID ;
    ******************************************
    *	the GUI Declaration Statement ends with ;
    *	the <guiType> can be either: Circle, Box, Triangle or Label.
    *
    */
     
    i1       = NULL;

    {
        // Guolice.g:969:2: ( guiType ':' i1= ID ';' )
        // Guolice.g:969:4: guiType ':' i1= ID ';'
        {
            FOLLOWPUSH(FOLLOW_guiType_in_guiDecStatement1343);
            guiType34=guiType(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleguiDecStatementEx;
            }

             MATCHT(12, &FOLLOW_12_in_guiDecStatement1345); 
            if  (HASEXCEPTION())
            {
                goto ruleguiDecStatementEx;
            }

            i1 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_guiDecStatement1349); 
            if  (HASEXCEPTION())
            {
                goto ruleguiDecStatementEx;
            }

            {

                			//string guiTypeText = (string)(char*)((STRSTREAM->toStringTT(STRSTREAM, guiType34.start, guiType34.stop))->chars);
                			string guiTypeText = (string)(char*)((i1->getText(i1))->chars);
                			guiTypeText += " ( ";
                			guiTypeText += (string)(char*)((STRSTREAM->toStringTT(STRSTREAM, guiType34.start, guiType34.stop))->chars);
                			guiTypeText += " ) ";

                			//temp = new Node(guiTypeText);
                			node= new Node(guiTypeText);
                			node->setType(Node::VAR);
                			
                			variableIDs[node] = (string)(char*)((i1->getText(i1))->chars);
                			
                			//guiDeclNodes.push_back(temp);
                		
            }
             MATCHT(18, &FOLLOW_18_in_guiDecStatement1359); 
            if  (HASEXCEPTION())
            {
                goto ruleguiDecStatementEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleguiDecStatementEx; /* Prevent compiler warnings */
    ruleguiDecStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end guiDecStatement */

/** 
 * $ANTLR start guiTerm
 * Guolice.g:989:1: guiTerm returns [Node* node] : ( ID | '(' guiPositionExpression ')' );
 */
static Node*
guiTerm(pGuoliceParser ctx)
{   
    Node* node = NULL;

    pANTLR3_COMMON_TOKEN    ID35;
    Node* guiPositionExpression36;
    #undef	RETURN_TYPE_guiPositionExpression36
    #define	RETURN_TYPE_guiPositionExpression36 Node*

    /* Initialize rule variables
     */


     Node* temp;
    /** 
    *	the  GUI Term is either a gui which we expressed it with its ID
    *	or it's a guiPositionExpression which represents a position relation between gui terms. 
    *
    */

    ID35       = NULL;
    guiPositionExpression36 = NULL;

    {
        {
            //  Guolice.g:997:2: ( ID | '(' guiPositionExpression ')' )
            
            ANTLR3_UINT32 alt24;

            alt24=2;

            switch ( LA(1) ) 
            {
            case ID:
            	{
            		alt24=1;
            	}
                break;
            case 13:
            	{
            		alt24=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto ruleguiTermEx;
            }

            switch (alt24) 
            {
        	case 1:
        	    // Guolice.g:997:4: ID
        	    {
        	        ID35 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_guiTerm1379); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleguiTermEx;
        	        }

        	        {
        	             node= new Node((string)(char*)((ID35->getText(ID35))->chars)); node->setType(Node::VAR); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // Guolice.g:998:4: '(' guiPositionExpression ')'
        	    {
        	         MATCHT(13, &FOLLOW_13_in_guiTerm1386); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleguiTermEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_guiPositionExpression_in_guiTerm1388);
        	        guiPositionExpression36=guiPositionExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleguiTermEx;
        	        }

        	         MATCHT(14, &FOLLOW_14_in_guiTerm1390); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleguiTermEx;
        	        }

        	        {
        	             node= guiPositionExpression36; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleguiTermEx; /* Prevent compiler warnings */
    ruleguiTermEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end guiTerm */

/** 
 * $ANTLR start guiPositionExpression
 * Guolice.g:1001:1: guiPositionExpression returns [Node* node] : g1= guiTerm ( positionKeyword g2= guiTerm )+ ;
 */
static Node*
guiPositionExpression(pGuoliceParser ctx)
{   
    Node* node = NULL;

    Node* g1;
    #undef	RETURN_TYPE_g1
    #define	RETURN_TYPE_g1 Node*

    Node* g2;
    #undef	RETURN_TYPE_g2
    #define	RETURN_TYPE_g2 Node*

    GuoliceParser_positionKeyword_return positionKeyword37;
    #undef	RETURN_TYPE_positionKeyword37
    #define	RETURN_TYPE_positionKeyword37 GuoliceParser_positionKeyword_return

    /* Initialize rule variables
     */


     Node* temp;
    /** 
    *	the  GUI Position Expression syntax is:
    ******************************************
    *	<guiTerm> <positionKeyword> <guiTerm>
    ******************************************
    *	the <positionKeyword>s are: LeftOf, RightOf, Above, Below, Contains and Intersect.
    *
    */
     
    g1 = NULL;
    g2 = NULL;

    {
        // Guolice.g:1012:2: (g1= guiTerm ( positionKeyword g2= guiTerm )+ )
        // Guolice.g:1012:4: g1= guiTerm ( positionKeyword g2= guiTerm )+
        {
            FOLLOWPUSH(FOLLOW_guiTerm_in_guiPositionExpression1414);
            g1=guiTerm(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleguiPositionExpressionEx;
            }

            {
                 temp = g1; 
            }
            // Guolice.g:1013:3: ( positionKeyword g2= guiTerm )+
            {
                int cnt25=0;

                for (;;)
                {
                    int alt25=2;
            	switch ( LA(1) ) 
            	{
            	case 53:
            	case 54:
            	case 55:
            	case 56:
            	case 57:
            	case 58:
            		{
            			alt25=1;
            		}
            	    break;

            	}

            	switch (alt25) 
            	{
            	    case 1:
            	        // Guolice.g:1013:4: positionKeyword g2= guiTerm
            	        {
            	            FOLLOWPUSH(FOLLOW_positionKeyword_in_guiPositionExpression1421);
            	            positionKeyword37=positionKeyword(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleguiPositionExpressionEx;
            	            }

            	            FOLLOWPUSH(FOLLOW_guiTerm_in_guiPositionExpression1425);
            	            g2=guiTerm(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleguiPositionExpressionEx;
            	            }

            	            {

            	                			Node* positionNode = new Node((string)(char*)((STRSTREAM->toStringTT(STRSTREAM, positionKeyword37.start, positionKeyword37.stop))->chars));
            	                			positionNode->setType(Node::OP);
            	                			
            	                			positionNode->addChild(temp);
            	                			positionNode->addChild(g2);

            	                			temp = positionNode;

            	                			node= temp;
            	                		
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt25 >= 1 )
            		{
            		    goto loop25;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleguiPositionExpressionEx;
            	}
            	cnt25++;
                }
                loop25: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleguiPositionExpressionEx; /* Prevent compiler warnings */
    ruleguiPositionExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end guiPositionExpression */

/** 
 * $ANTLR start guiComparisonExpression
 * Guolice.g:1027:1: guiComparisonExpression returns [Node* node] : i1= ID guiComparsionTerm i2= ID ;
 */
static Node*
guiComparisonExpression(pGuoliceParser ctx)
{   
    Node* node = NULL;

    pANTLR3_COMMON_TOKEN    i1;
    pANTLR3_COMMON_TOKEN    i2;
    GuoliceParser_guiComparsionTerm_return guiComparsionTerm38;
    #undef	RETURN_TYPE_guiComparsionTerm38
    #define	RETURN_TYPE_guiComparsionTerm38 GuoliceParser_guiComparsionTerm_return

    /* Initialize rule variables
     */



    /** 
    *	the  GUI Comparison Expression syntax is:
    ******************************************
    *	ID <guiComparsionTerm> ID
    ******************************************
    *	the <guiComparsionTerm>s are: SmallerThan, BiggerThan and EqualTo.
    *
    */
     
    i1       = NULL;
    i2       = NULL;

    {
        // Guolice.g:1038:2: (i1= ID guiComparsionTerm i2= ID )
        // Guolice.g:1038:5: i1= ID guiComparsionTerm i2= ID
        {
            i1 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_guiComparisonExpression1456); 
            if  (HASEXCEPTION())
            {
                goto ruleguiComparisonExpressionEx;
            }

            FOLLOWPUSH(FOLLOW_guiComparsionTerm_in_guiComparisonExpression1459);
            guiComparsionTerm38=guiComparsionTerm(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleguiComparisonExpressionEx;
            }

            i2 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_guiComparisonExpression1464); 
            if  (HASEXCEPTION())
            {
                goto ruleguiComparisonExpressionEx;
            }

            {

                			Node* idNode1 = new Node((string)(char*)((i1->getText(i1))->chars));
                			idNode1->setType(Node::VAR);
                			Node* idNode2 = new Node((string)(char*)((i2->getText(i2))->chars));
                			idNode2->setType(Node::VAR);

                			node= new Node((string)(char*)((STRSTREAM->toStringTT(STRSTREAM, guiComparsionTerm38.start, guiComparsionTerm38.stop))->chars));
                			node->setType(Node::OP);
                			node->addChild(idNode1);
                			node->addChild(idNode2);
                		
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleguiComparisonExpressionEx; /* Prevent compiler warnings */
    ruleguiComparisonExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end guiComparisonExpression */

/** 
 * $ANTLR start guiStatement
 * Guolice.g:1053:1: guiStatement returns [Node* node] : ( guiDecStatement | guiPositionExpression ';' | guiComparisonExpression ';' );
 */
static Node*
guiStatement(pGuoliceParser ctx)
{   
    Node* node = NULL;

    Node* guiDecStatement39;
    #undef	RETURN_TYPE_guiDecStatement39
    #define	RETURN_TYPE_guiDecStatement39 Node*

    Node* guiPositionExpression40;
    #undef	RETURN_TYPE_guiPositionExpression40
    #define	RETURN_TYPE_guiPositionExpression40 Node*

    Node* guiComparisonExpression41;
    #undef	RETURN_TYPE_guiComparisonExpression41
    #define	RETURN_TYPE_guiComparisonExpression41 Node*

    /* Initialize rule variables
     */



    /** 
    *	the  GUI Statements are either GUI Declaration Statemet, GUI Position Expression
    *	or GUI Comparison Expression.
    *	and the GUI staements are like the regular statements should end with ';'
    *
    */
     
    guiDecStatement39 = NULL;
    guiPositionExpression40 = NULL;
    guiComparisonExpression41 = NULL;

    {
        {
            //  Guolice.g:1062:2: ( guiDecStatement | guiPositionExpression ';' | guiComparisonExpression ';' )
            
            ANTLR3_UINT32 alt26;

            alt26=3;

            switch ( LA(1) ) 
            {
            case 47:
            case 48:
            case 49:
            case 50:
            	{
            		alt26=1;
            	}
                break;
            case ID:
            	{
            		switch ( LA(2) ) 
            		{
            		case 53:
            		case 54:
            		case 55:
            		case 56:
            		case 57:
            		case 58:
            			{
            				alt26=2;
            			}
            		    break;
            		case 59:
            		case 60:
            		case 61:
            			{
            				alt26=3;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 26;
            		    EXCEPTION->state        = 2;


            		    goto ruleguiStatementEx;
            		}

            	}
                break;
            case 13:
            	{
            		alt26=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 26;
                EXCEPTION->state        = 0;


                goto ruleguiStatementEx;
            }

            switch (alt26) 
            {
        	case 1:
        	    // Guolice.g:1062:4: guiDecStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_guiDecStatement_in_guiStatement1489);
        	        guiDecStatement39=guiDecStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleguiStatementEx;
        	        }

        	        {
        	             node= guiDecStatement39 ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // Guolice.g:1064:4: guiPositionExpression ';'
        	    {
        	        FOLLOWPUSH(FOLLOW_guiPositionExpression_in_guiStatement1498);
        	        guiPositionExpression40=guiPositionExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleguiStatementEx;
        	        }

        	        {
        	             node= guiPositionExpression40 ;
        	        }
        	         MATCHT(18, &FOLLOW_18_in_guiStatement1506); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleguiStatementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Guolice.g:1066:4: guiComparisonExpression ';'
        	    {
        	        FOLLOWPUSH(FOLLOW_guiComparisonExpression_in_guiStatement1511);
        	        guiComparisonExpression41=guiComparisonExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleguiStatementEx;
        	        }

        	        {
        	             node= guiComparisonExpression41 ;
        	        }
        	         MATCHT(18, &FOLLOW_18_in_guiStatement1518); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleguiStatementEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleguiStatementEx; /* Prevent compiler warnings */
    ruleguiStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end guiStatement */

/** 
 * $ANTLR start evntHandleStatement
 * Guolice.g:1070:1: evntHandleStatement returns [Node* node] : ID '.' eventType '(' ( statement )* ')' ';' ;
 */
static Node*
evntHandleStatement(pGuoliceParser ctx)
{   
    Node* node = NULL;

    pANTLR3_COMMON_TOKEN    ID43;
    GuoliceParser_eventType_return eventType42;
    #undef	RETURN_TYPE_eventType42
    #define	RETURN_TYPE_eventType42 GuoliceParser_eventType_return

    Node* statement44;
    #undef	RETURN_TYPE_statement44
    #define	RETURN_TYPE_statement44 Node*

    /* Initialize rule variables
     */



    /** 
    *	the  event Handle Statement syntax is:
    ******************************************
    *	ID.<eventType>
    *	(
    *	<statements>
    *	) ;
    ******************************************
    *	the <eventType>s are: OnClick and KeyPress.
    *
    */
     
    ID43       = NULL;
    statement44 = NULL;

    {
        // Guolice.g:1084:2: ( ID '.' eventType '(' ( statement )* ')' ';' )
        // Guolice.g:1084:4: ID '.' eventType '(' ( statement )* ')' ';'
        {
            ID43 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_evntHandleStatement1538); 
            if  (HASEXCEPTION())
            {
                goto ruleevntHandleStatementEx;
            }

             MATCHT(46, &FOLLOW_46_in_evntHandleStatement1540); 
            if  (HASEXCEPTION())
            {
                goto ruleevntHandleStatementEx;
            }

            FOLLOWPUSH(FOLLOW_eventType_in_evntHandleStatement1542);
            eventType42=eventType(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleevntHandleStatementEx;
            }

            {

                				node= new Node((string)(char*)((STRSTREAM->toStringTT(STRSTREAM, eventType42.start, eventType42.stop))->chars));
                				Node* idNode = new Node((string)(char*)((ID43->getText(ID43))->chars));
                				idNode->setType(Node::VAR);
                				node->addChild(idNode);
                				node->setType(Node::OP);
                				
                			
            }
             MATCHT(13, &FOLLOW_13_in_evntHandleStatement1549); 
            if  (HASEXCEPTION())
            {
                goto ruleevntHandleStatementEx;
            }


            // Guolice.g:1093:2: ( statement )*

            for (;;)
            {
                int alt27=2;
                switch ( LA(1) ) 
                {
                case ID:
                case 13:
                case 18:
                case 20:
                case 21:
                case 22:
                case 25:
                case 47:
                case 48:
                case 49:
                case 50:
                	{
                		alt27=1;
                	}
                    break;

                }

                switch (alt27) 
                {
            	case 1:
            	    // Guolice.g:1093:4: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_evntHandleStatement1554);
            	        statement44=statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleevntHandleStatementEx;
            	        }

            	        {

            	            				node->addChild(statement44);
            	            			
            	        }

            	    }
            	    break;

            	default:
            	    goto loop27;	/* break out of the loop */
            	    break;
                }
            }
            loop27: ; /* Jump out to here if this rule does not match */

             MATCHT(14, &FOLLOW_14_in_evntHandleStatement1565); 
            if  (HASEXCEPTION())
            {
                goto ruleevntHandleStatementEx;
            }

             MATCHT(18, &FOLLOW_18_in_evntHandleStatement1567); 
            if  (HASEXCEPTION())
            {
                goto ruleevntHandleStatementEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleevntHandleStatementEx; /* Prevent compiler warnings */
    ruleevntHandleStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return node;
}
/* $ANTLR end evntHandleStatement */

/** 
 * $ANTLR start guiType
 * Guolice.g:1100:1: guiType : ( 'Box' | 'Circle' | 'Triangle' | 'Label' );
 */
static GuoliceParser_guiType_return
guiType(pGuoliceParser ctx)
{   
    GuoliceParser_guiType_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // Guolice.g:1101:2: ( 'Box' | 'Circle' | 'Triangle' | 'Label' )
        // Guolice.g:
        {
            if ( ((LA(1) >= 47) && (LA(1) <= 50)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_guiType0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_guiType0);    goto ruleguiTypeEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleguiTypeEx; /* Prevent compiler warnings */
    ruleguiTypeEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end guiType */

/** 
 * $ANTLR start eventType
 * Guolice.g:1107:1: eventType : ( 'OnClick' | 'KeyPress' );
 */
static GuoliceParser_eventType_return
eventType(pGuoliceParser ctx)
{   
    GuoliceParser_eventType_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // Guolice.g:1108:2: ( 'OnClick' | 'KeyPress' )
        // Guolice.g:
        {
            if ( ((LA(1) >= 51) && (LA(1) <= 52)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_eventType0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_eventType0);    goto ruleeventTypeEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleeventTypeEx; /* Prevent compiler warnings */
    ruleeventTypeEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end eventType */

/** 
 * $ANTLR start positionKeyword
 * Guolice.g:1112:1: positionKeyword : ( 'LeftOf' | 'RightOf' | 'Above' | 'Below' | 'Contains' | 'Intersect' );
 */
static GuoliceParser_positionKeyword_return
positionKeyword(pGuoliceParser ctx)
{   
    GuoliceParser_positionKeyword_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // Guolice.g:1113:2: ( 'LeftOf' | 'RightOf' | 'Above' | 'Below' | 'Contains' | 'Intersect' )
        // Guolice.g:
        {
            if ( ((LA(1) >= 53) && (LA(1) <= 58)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_positionKeyword0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_positionKeyword0);    goto rulepositionKeywordEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepositionKeywordEx; /* Prevent compiler warnings */
    rulepositionKeywordEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end positionKeyword */

/** 
 * $ANTLR start guiComparsionTerm
 * Guolice.g:1121:1: guiComparsionTerm : ( 'SmallerThan' | 'BiggerThan' | 'EqualTo' );
 */
static GuoliceParser_guiComparsionTerm_return
guiComparsionTerm(pGuoliceParser ctx)
{   
    GuoliceParser_guiComparsionTerm_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // Guolice.g:1122:2: ( 'SmallerThan' | 'BiggerThan' | 'EqualTo' )
        // Guolice.g:
        {
            if ( ((LA(1) >= 59) && (LA(1) <= 61)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_guiComparsionTerm0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_guiComparsionTerm0);    goto ruleguiComparsionTermEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleguiComparsionTermEx; /* Prevent compiler warnings */
    ruleguiComparsionTermEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end guiComparsionTerm */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
